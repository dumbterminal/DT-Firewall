#!/bin/bash
#
# Dumb Terminal IPTables Firewall Script
#  script to aid the use of IPTables - http://www.netfilter.org/projects/iptables/index.html
#   more aid from: http://pikt.org/pikt/samples/iptables_tcp_flags_programs.cfg.html
#                  http://pettingers.org/code/firewall.html
#                  http://www.newartisans.com/2007/09/neat-tricks-with-iptables.html
# This script does not make extra tables for the eye candy of the user.
#  In theory it will run faster because the lack of table processing.
#
# http://dt.tehspork.com
# Dumb Terminal
#  Smaller than Life Projects
# Main Page: http://dt.tehspork.com
# Git Repo: https://github.com/dumbterminal/
# By: MikereDD & veekahn
# email: dumbterminal -at- tehspork.com
##
# Much Thanx to Veekahn
#  for helping with specific IP lines. :)
#
## Last Update
## Mon May 15 13:40:13 PST 2011
#  2011-05-15
#
## 'TODO' (among the objects listed in the "iptables output order"
#  Layer 107 - Allow Local host  -  remove ?
#        108, is `allow lo iface` necessary ?
#  Layer 112, find out more info
#   _SRV first parameter: allow vs drop vs (maybe reject-with -code is ugly)
#
# implement something like Cutter:
#    http://www.lowth.com/cutter/#mozTocId284461
#
#  make Restart do what it says it's doing
#  kernel firewall WARNING logging (log level 4 -default)
#  SCRIPT=  (change it to dt.firewall ?)
#  SPOOF_IPS (on WAN only), WAN vs LAN auto detection per iface - reseach -s and -d spoofed ips
#  LogAllValidPackets - input, forward, output
#   allow "BOTH" (all|any?) option for Proto in InsertLayerRule
#   implement iface parameter for InsertLayerRule
# implement OPTIONAL 'clean' vs 'super fast' operational mode
#   super-fast: no unnecessary chains
#   clean: chains for each 'layer' -ish
#   option for 'pro' style, remove input checking
#  re-classify LayerNumbers - make larger ranges?
#       filter -                     INPUT 101-125  FORWARD 131-155  OUTPUT 161-185
#       mangle - PreRouting 201-219  Input 221-239  FORWARD 241-259  OUTPUT 261-279  PostRouting 281-299
#       nat    - PreRouting 301-329  POSTROUTING 331-359  OUTPUT 361-389
#
VER="2.0beta1"
# Add a config file for easy edits
# /etc/DTfw/dtfw.config
#
#VER="1.9beta2"
# move out of the usr/local folder and into /etc/DTfw
#VER="1.9beta1"
# Multiple Dynamic DNS Support
# Clean up some code
# TODO: Clean the code completely
#VER="1.8beta1"
# Dynamic DNS support
#  Adding Dynamic DNS host support to enable remote access.
#     => runs a check on dns every 15 mins and flushes DYNAMIC rule if IP has changed.
#  TODO: Starting with single DNS host and will convert to using a list.
#VER="1.7beta7"
# swapped LayerRule 105 and 106
#  TODO: should Connection Tracking be above White+Black lists?
#     => if so, refresh blacklist function to initiate tcp-rst+fin packets to new Blacklisted IPs
#     => should sshguard be after Connetion Tracking ?
# much work on the IP Spoofing rules
#  IFACES+=( "<LAN | WAN>" "<interface | IP>" )
#  if a duplicate interface/ip exists for both LAN and WAN modes, the WAN is dropped from the rule set
#  duplicates are dropped from the rule set
##  Working On: Picky_Spoof_Rules. Allows users to specify which ip's to block when spoof-ip checking
#  TODO: work on LAN stuff and specific subnet broadcast services
#     ==> automatic subnet broadcast services?
# TODO for 1.7beta6 (plus the list above)
# TODO, make DHCP ip's work (something with broadcast range stuff)
# TODO: work on IFACES still from 1.7beta5
#
#VER="1.7beta6"
# added comments ability to whitelist and blacklist
# added a method to clean up used array elements for the LayerRule and _SRV rules
#  tested across 75 runs each for speed increase. got .01 second better but for every additional test
#   the speed difference became less and less significant
# added Fancy Chain options, the look is now very slick
# TODO for 1.7beta6 (plus the list above)
# TODO, make DHCP ip's work (something with broadcast range stuff)
# TODO: work on IFACES still from 1.7beta5
#
#VER="1.7beta5"
# added a layer, 118, for mDNS and other broadcast range'd goodies
# added RegExp for checking IP/Cidr and PORT:PORT (port ranges) along with negation tests
#  now invalid arguments to any LayerRule or _SRV rule will generate an appropriate error
#    with the user-input checking there is a slight lag in at least the LayerRule section
## idea: TODO: option for 'pro' style, remove input checking
# added Show_Protocol_Warning for _SRV rules (TODO: implement for LayerRules)
#  this will warn that the script does not check past tcp/udp protocols
# renumbered the LayerRules
# working on: IFACES= LAN vs WAN vs (lan iface/ip)
#             + broadcast range services
## idea: TODO: do not Masquerade/DNAT special ip's (spoof-able ips)
#
#VER="1.7beta4"
# beta3
# working on the ! case in  _SRV areas
# next, allow "all" for anywhere a proto ip:port is accepted
#  finished   !  case in LayerRule
## beta4: I think all LayerRule + _SRV rules now work flawlessly when ip or port is set to "any" or "all"
##    both LayerRule and _SRV also should work with with the not case   !   in any parameter
##  working on: IFACES= LAN vs WAN vs (lan iface/ip)
##              + broadcast range services


# iptables output order/levels
# INPUT: InsertLayerRule
# 1  101 LogAllPackets_INPUT (optional)
# 1  102 whitelist
# 1  103 sshguard
# 1  104 blacklist
# A  105 connection tracking: ESTABLISHED,RELATED
# A  106 block spoofing (for WAN use only!) [TODO: auto-detection]
# A ?107 allow localhost [ LAN only? - what is source of this? allows SPOOFING ]
# A ?108 allow lo iface
# A  109 check for INVALID or Fragment packets
# A  110 bad packet/(scan?) checks
# A  111 [NUKED for time being]
## A  109 drop corrupt packets
## A  110 bad packets/scans
## A  111 force fragment packet check
# A ?112 special port 111, 113, 520 cases
# A  113 icmp ping allow/deny/limit
# A  114 other flood protections - FORWARDing limits - TODO
# A  115 block brute force
# A  116 good-packet ACCEPT - allows:
#      - General Services (specific destination port)
#      - Specific Port Services (source and destination)
#      - Specific Source IP:Port, Dest Port
#      - Specific Source IP, Dest Port
# A  117 samba [enabled for spceified ip/subnet]
##   118  spoof-part 2 (lan vs wan) - mDNS (224.0.0.251:5353 + other options)
#       mDNS / IPP
#       other 224/225 services
# A  119 reject/drop logging (last rule)
# FORWARD:
# 1  131 LogAllPackets_FORWARD (optional)
# A  132 connection tracking: ESTABLISHED,RELATED
# A  133 force ACCEPT rules [TODO]
# A  134 drop corrupt packets
# A  135 bad packets/scans  # [ do these need to exist ?? ]
# A  136 force fragment packet check
# A  137 Flood Protection - limit DoS
# A  138 good-packet ACCEPT rules [TODO] - destinations!
# A  139 if not ppp0 then allow: NEW,ESTABLISHED,RELATED
# A  140 reject/drop logging (last rule)
# OUTPUT:
# 1  161 LogAllPackets_OUTPUT (optional)
# 1  162 WHITELIST ( load INPUT whitelist, load second file, load array ) not_TODO
# 1  163 BLACKLIST ( load second file, load array ) TODO (optional)
# A  164 connection tracking: ESTABLISHED,RELATED [disabled on force outbound corrupt packet check]
# A  165 accept lo iface OUTPUT
# A  166 drop corrupt packets
# A  167 DROP/REJECT rules [TODO] - destination port blocking (source IP blocking) - iface?
# A  168 new+connection tracking: NEW,ESTABLISHED,RELATED
# A  169 reject/drop logging (last rule)


## list initializations, don't edit!
  SAMBA=( )
  SPOOF_IPS=( )
  Block_Ping=( )
  sshguard_params=( )
  sshguard_moreps=( )
  OTHER_FLOODS=( )
  BruteForce=( )
  IFACES=( )
  PD_SRV=( )    # Proto,  Dest port
  PID_SRV=( )   # Proto,  src IP,  Dest port
  PSD_SRV=( )   # Proto,  Src port,  Dest port
  PISD_SRV=( )  # Proto,  src IP,  Src port,  Dest port
  LayerRule=( )
  # some colors
  ReD='\033[0;31m'
  GrN='\033[0;32m'
#  YlO='\033[0;33m'
#  BlU='\033[0;34m'
#  MaG='\033[0;35m'
#  CyN='\033[0;36m'
#  UnL='\033[33;04m'
  DeF='\033[0m'
## end initializations

# Path to Script  - used for  `restart`
SCRIPT=/usr/bin/dtfw

## Specify where IP Tables is located
# not necessary for:
#   archlinux, debian, redhat, centos
IPTABLES='/usr/sbin/iptables'

# Path to iptables-save
IPTABLESSAVE=/usr/sbin/iptables-save

# Path to iptables-restore
IPTABLESRESTORE=/usr/sbin/iptables-restore

# Path to IPTables Rules
FWSAVE=/etc/iptables/iptables.rules

# Location of ModProbe
MODPROBE=/sbin/modprobe

## List Locations
WHITELIST=/etc/DTfw/dtfw-lists/dtfw_whitelist.lst
BLACKLIST=/etc/DTfw/dtfw-lists/dtfw_blacklist.lst
#OUT_WHITELIST=/usr/local/etc/DTfw/dtfw-lists/dtfw_whitelist_OUTS.lst   # most likely not implemented
OUT_BLACKLIST=/etc/DTfw/dtfw-lists/dtfw_blacklist_OUTS.lst   # not implemented - optional

# DTfw DynamicHosts script - single IP
# working on Mulitple Dynamic IP list
DYNHOSTSCRIPT=/usr/bin/dtfw_dynamichosts
DYNDNSWHITELIST=/etc/DTfw/dtfw_dynamiclists/dtfw_dynamic_whitelist.lst

# DTfw Config file path
DTCONFIG=/etc/DTfw/dtfw.config

# Server is behind a router or directly connected to the internet
#  deals directly with IPSpoofing and Broadcasts
### not fully implemented
#IFACES="LAN"
#IFACES+=("WAN" "")
IFACES+=("WAN" "eth0") # drops
IFACES+=("LAN" "eth0")
IFACES+=("LAN" "eth1") # dhcp
IFACES+=("WAN" "192.168.1.1")
IFACES+=("WAN" "eth1") # drops
#IFACES+=("WAN" "130.157.0.0")
IFACES+=("LAN" "eth1:0")
IFACES+=("LAN" "eth1:1")
IFACES+=("LAN" "eth2")
IFACES+=("LAN" "eth2")
#IFACES+=("WAN" "eth10")
#IFACES+=("WAN" "eth20")

# IFACES="WAN"
## IFACES+=("LAN" "eth0")  ## not implemented
## IFACES+=("WAN" "eth1")  ## not implemented
## IFACES+=("LAN" "")  ## not implemented
# LAN allows broadcasts


# true/false
##
# enable logging in general
EnableLog="true"
# log prefix for logged segments' prefixes
LogPrefix="dtFW: "
##
LOG_ALL_PACKETS="false"
##
# if a non tcp/udp/icmp prototocol is used, display a warning
# currently works with _SRV rules  (TODO: LayerRule warning)
Show_Protocol_Warning="false"
##
# fancy chain structure
FancyChains="true"  # master switch, disable all via false
# picky fancy chain rules - only work when FancyChains is true
FancyListsIN="true"
FancySpoofs="true"
FancyInvalid_Frag="true"
FancyBadTCP="TRUE"
FancyBruteForce="true"
FancyServices="true"
##
# Check Outbound traffic and restrict sending corrupt data
#Block_Corrupt_Outbound="true"
Block_Corrupt_Outbound="false"
##
# Block Ping (ipv4) - (aka icmp ping - allow/deny/limit)
  #  options:  "false | no";  "drop";  "reject" "<mode 1-6>";  "limit" "<RATE>" "<burst>"
  ## RATE =  <packets> / <s|second> | <m|minute> | <h|hour> | <d|day>
  ## REJECT Modes:
   # 1: icmp-port-unreachable
   # 2: icmp-net-unreachable
   # 3: icmp-host-unreachable
   # 4: icmp-proto-unreachable
   # 5: icmp-net-prohibited
   # 6: icmp-host-prohibited
Block_Ping=("no") #Block_Ping=("false")
 #Block_Ping=("DROP")
 #Block_Ping=("reject" "3")
 #Block_Ping=("limit" "1/s" "5")
##
# Allow same-subnet cidr /24 Broadcasts inbound for LAN (wan not implemented)
Allow_lan_inBCast="true";   # NOT IMPLEMENTED
 # 1 2 or blocks of 4 +1  broadcast
 #wake on lan
 #RIP
 # intel router switching
 # 10 routers that dynamically route, then use bcast
##
# end true/false


# Other flood protections [limit rate in FORWARD] - prevent DoS
#   http://netfilter.org/documentation/HOWTO/packet-filtering-HOWTO-7.html
# <rate>/ <s|second> | <m|minute> | <h|hour> | <d|day>
OTHER_FLOODS+=("syn flood" "1/s")
OTHER_FLOODS+=("furtive port scanner" "1/s")
OTHER_FLOODS+=("ping of death" "1/s")


## Inbound Malformed/Bad Packet drop
#
DropTableName="MY_DROP"
LOG_Droped="true"

# Source the config file
[[ -f /etc/DTfw/dtfw.config ]] && . /etc/DTfw/dtfw.config

# Specific:  Proto,  Source IP:Port,  Dest IP:Port,  Action
# LayerRule=+( "<layer> "<DESC>" "<tcp|udp|any>" "<src ip|any>" "<src port|any>" "<dest ip|any>" "<dest port|any>" "<Action>"
  ##  Action Modes:
    ##  ACCEPT
    ##  DROP
    ##  Reject <mode>
    ##  Limit <rate> <burst>
    ##  LOG <log prefix text>
  ## Reject Modes:
    ## 1: icmp-port-unreachable       ## 2: icmp-net-unreachable
    ## 3: icmp-host-unreachable       ## 4: icmp-proto-unreachable
    ## 5: icmp-net-prohibited         ## 6: icmp-host-prohibited
    ## 7: tcp-reset
  ## Limit Modes:
    ## rate:   <packets>/ <s|second> | <m|minute> | <h|hour> | <d|day>
    ## burst:  # packet burst

#LayerRule+=( "169" "testah" "TCP" "" "8080" "" "81" "reject 3" )
#LayerRule+=( "169" "testah" "TCP" "" "8080" "" "81" "drop" )
#LayerRule+=( "169" "testah" "TCP" "" "8080" "" "81" "limit 1024/h 4" )
#LayerRule+=( "169" "testah" "TCP" "" "8080" "" "81" "log log prefix text" )
##LayerRule+=( "168" "testah" "TCP" "" "8080" "" "81" "limit 8/s 5" )


#INPUT
#LayerRule+=( "169" "t 1" " TCP" "! 127.0.0.1/32" "! 80" "! 127.0.0.2/32" "! 80" "ACCEPT" )
#LayerRule+=( "169" "t 1" "! TCP" "! 127.0.0.1/32" "any" "! 127.0.0.2/32" "all" "ACCEPT" )
LayerRule+=( "169" "t 169" "ipv6-icmp" "! 127.0.0.1/32" "any" "AnY" "any" "ACCEPT" )
#LayerRule+=( "101" "t 101 ANY" "any" "any" "any" "any" "any" "ACCEPT" )
#LayerRule+=( "102" "t 102" "dumbass protocol" "idiot source ip" "what sport" "some inbound ip" "no port" "dumbass" )
LayerRule+=( "101" "t 101" "" "" "" "" "" "" )
LayerRule+=( "102" "t 102" "" "" "" "" "" "" )
LayerRule+=( "103" "t 103" "" "" "" "" "" "" )
#LifaceRule+=("103" "t 103" "eth0" )
#LayerRule+=( "103" "t 103" "iface"  "proto" "s ip" "s port" "d ip" "d port" "action" )
LayerRule+=( "104" "t 104" "" "" "" "" "" "" )
LayerRule+=( "105" "t 105 before connection tracking" "" "" "" "" "" "" )
LayerRule+=( "106" "t 106 before SPOOF CHECKS" "" "" "" "" "" "" )
LayerRule+=( "107" "t 107" "" "" "" "" "" "" )
LayerRule+=( "108" "t 108" "" "" "" "" "" "" )
LayerRule+=( "109" "t 109" "" "" "" "" "" "" )
LayerRule+=( "110" "t 110" "" "" "" "" "" "" )
LayerRule+=( "111" "t 111" "" "" "" "" "" "" )
LayerRule+=( "112" "t 112" "" "" "" "" "" "" )
LayerRule+=( "113" "t 113" "" "" "" "" "" "" )
LayerRule+=( "114" "t 114" "" "" "" "" "" "" )
LayerRule+=( "115" "t 115" "" "" "" "" "" "" )
LayerRule+=( "116" "t 116" "" "" "" "" "" "" )
LayerRule+=( "117" "t 117" "" "" "" "" "" "" )
LayerRule+=( "118" "t 118" "" "" "" "" "" "" )
LayerRule+=( "119" "t 119" "" "" "" "" "" "" )
#FORWARD
LayerRule+=( "131" "t 131" "" "" "" "" "" "" )
LayerRule+=( "132" "t 132" "" "" "" "" "" "" )
LayerRule+=( "133" "t 133" "" "" "" "" "" "" )
LayerRule+=( "134" "t 134" "" "" "" "" "" "" )
LayerRule+=( "135" "t 135" "" "" "" "" "" "" )
LayerRule+=( "136" "t 136" "" "" "" "" "" "" )
LayerRule+=( "137" "t 137" "" "" "" "" "" "" )
LayerRule+=( "138" "t 138" "" "" "" "" "" "" )
LayerRule+=( "139" "t 139" "" "" "" "" "" "" )
LayerRule+=( "140" "t 140" "" "" "" "" "" "" )
#OUTPUT
LayerRule+=( "161" "t 161" "" "" "" "" "" "" )
LayerRule+=( "162" "t 162" "" "" "" "" "" "" )
LayerRule+=( "163" "t 163" "" "" "" "" "" "" )
LayerRule+=( "164" "t 164" "" "" "" "" "" "" )
LayerRule+=( "165" "t 165" "" "" "" "" "" "" )
LayerRule+=( "166" "t 166" "" "" "" "" "" "" )
LayerRule+=( "167" "t 167" "" "" "" "" "" "" )
LayerRule+=( "168" "t 168" "" "" "" "" "" "" )
LayerRule+=( "169" "t 169" "" "" "" "" "" "" )
LayerRule+=( "170" "t 170" "" "" "" "" "" "" )
LayerRule+=( "171" "t 171" "" "" "" "" "" "" )





### log all remaining traffic
INPUT_LOG_BOGUS="true"
FORWARD_LOG_BOGUS="true"
OUTPUT_LOG_BOGUS="true"
### last line should REJECT with TCP Reset, or DROP
#  = "DROP" or "REJECT"
INPUT_LAST_LINE="REJECT"   # TODO: make variable a better name
FORWARD_LAST_LINE="REJECT"
OUTPUT_LAST_LINE="REJECT"

## Bandwidth Rates
# BW_Rates="<off | packet/rate>"
BW_Rates="1700/h"
# hard-coded "off"


##
# output iptable lines to STD OUT
IPT_STD_OUT=0
#IPT_STD_OUT=1









#### stay the hell out of the area below this line ####
#######################################################

# if iptables location is not set, find common location
if [ ! -x "${IPTABLES}" ]; then
  # debian+redhat+centos
  if [   -x /sbin/iptables     ]; then   IPTABLES=/sbin/iptables
  # archlinux
  elif [ -x /usr/sbin/iptables ]; then   IPTABLES=/usr/sbin/iptables
  else
      LOCATEIPT=`whereis iptables | awk '{print $2}'`
      if [ -x "${LOCATEIPT}" ]; then
          IPTABLES=${LOCATE}
      else
          echo -e "${ReD}error locating iptables, please specify location or correct execution permissions${DeF}"
          exit
      fi
  fi
fi
if (( IPT_STD_OUT == 1 )); then
    IPTABLES="echo -e ${UnL}${IPTABLES}${DeF}"
fi

#
shopt -s nocasematch
if [[ "$FancyChains" != "true" && "$FancyChains" != 0 ]]; then
    FancyListsIN=0
    FancySpoofs=0
    FancyInvalid_Frag=0
    FancyBadTCP=0
    FancyBruteForce=0
    FancyServices=0
fi
shopt -u nocasematch

### InsertLayerRule  and  _SRV    helper functions

#
# http://fixunix.com/networking/11507-port-forwarding-loopback-device.html
#  sudo iptables -t nat -A PREROUTING -p tcp --dport 889 -i lo -j REDIRECT --to-port 8080
#  For port forwarding on lo, you need to use the OUTPUT chain instead of PREROUTING
#   http://iptables.rlworkman.net/chunkyhtml/x4529.html
#  iptables -I INPUT 1 -p tcp -s spine.inverted.be --dport 11111 -j ACCEPT
#  iptables -t nat -A PREROUTING -p tcp -s spine.inverted.be --dport 11111 -j REDIRECT --to-port 443
# ## port 80 and 443 always open; use special subdomain:443 (https) to genearate hash - web-end: port knock from UDP (spoof packets!)
# ##   override port 80 to SSH for 5 seconds

PortRangeREGEX='^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9][0-9]|[0-6][0-4][0-9][0-9][0-9]|[0-5]?([0-9])?([0-9])?([0-9])?([0-9])){1}?(:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9][0-9]|[0-6][0-4][0-9][0-9][0-9]|[0-5]?([0-9])?([0-9])?([0-9])?([0-9]))){0,1}$'
function testNegationPort {
    local _result=$1
    local thisResult="-0"
    if [ "${2}" == "!" ]; then  thisResult="$3";
    elif [[ !("${2}" =~ ${PortRangeREGEX}) ]]; then thisResult=-1; fi
    eval $_result="'$thisResult'"
}
IPCIDRREGEX='^((25[0-5]|2[0-4][0-9]|([01])?([0-9])?([0-9]))\.){3}((25[0-5]|2[0-4][0-9]|([01])?([0-9])?([0-9]))){1}?(/(3[0-2]|[0-2][0-9]|[0-9])){0,1}$'
function testNegationIP {
    local _result=$1
    local thisResult="-0"
    if [ "${2}" == "!" ]; then  thisResult="$3";
    elif [[ !(${2} =~  $IPCIDRREGEX) ]]; then thisResult=-1; fi
    eval $_result="'$thisResult'"
}
function testNegationProto {
    local _result=$1
    local thisResult="-0"
    if [ "${2}" == "!" ]; then  thisResult="$3";  fi
    eval $_result="'$thisResult'"
}
function testDontCare {
    locale _result=$1
    locale thisResult=0
    shopt -s nocasematch
    if [[ "${2}" == "any" || "${2}" == "all" || "${2}" == "no" ]]; then thisResult="$3";  fi
    shopt -u nocasematch
    eval $_result="'$thisResult'"
}

### Level function; for insertion of allows/deny's at a specific level
#   uses the variable LayerRule=+( "<layer> "<DESC>" "<tcp|udp|both>" "<src ip>" "<src port>" "<dest ip>" "<dest port>" "<accept/drop/reject/limit>" )
#    leave an item blank, "", to skip the parameter (if no protocol, then no src/dest port can be used!)
##  an advanceed PISD_SRV modification (Protocol, source IP, Source port, Destination port
#
#    Specific:  Proto,  Source IP:Port,  Dest IP:Port
#    "<layer>" "<DESC>" "<tcp|udp>" "<src ip>" "<src port>" "<dest ip>" "<dest port>" "<accept | drop |
#                                                                                             reject <method #>
#                                                                                             limit  <rate> <burst>
#                                                                                             log <log-text>
#
##  if "<layer>" is equal to $1, then insert rule before

function trim {
    local _result=$1
    local thisR=""
    thisR=`echo -n "${2}" | sed 's/^ *//' | sed 's/ *$//'`
    eval $_result="'$thisR'"
}

#sz_LayerRule=${#LayerRule[@]}
function InsertLayerRule {
    shopt -s nocasematch
    sz_LayerRule=${#LayerRule[@]}
    for (( i=0; i< sz_LayerRule; i++ ))
    do
        if (( $i % 8 == 0 )); then
        if [ "${1}" == "${LayerRule[$((i+0))]}" ]; then
            layer=${LayerRule[$((i+0))]}
            desc="${LayerRule[$((i+1))]}"

            Proto="";  srcIP=""; SrcP="";
            DestIP=""; DestP=""; action="";

            if [ -n "${LayerRule[$((i+2))]}" ]; then
                Proto="${LayerRule[$((i+2))]}"
                if [[ "${Proto}" == "all" || "${Proto}" == "any" ]]; then
                    Proto=""
                else
                    testNegationProto result ${Proto}
                    ## TODO: /etc/protocols   check if a valid protocol/number
                    if [ "${result}" == "-0" ]; then
                        Proto="-p ${Proto}"
                    else
                        Proto="! -p ${result}"
                        if [[ ( "${LayerRule[$((i+4))]}" != "any" && "${LayerRule[$((i+4))]}" != "all" ) || ( "${LayerRule[$((i+6))]}" != "any" && "${LayerRule[$((i+6))]}" != "all" ) ]]; then
                            echo -e "${ReD}Error in LayerRule${GrN} ${LayerRule[$((i+1))]} ${ReD}with protocal${GrN} ${LayerRule[$((i+2))]} ${ReD}with source port${GrN} ${LayerRule[$((i+4))]} ${ReD} and destination port${GrN} ${LayerRule[$((i+6))]}${DeF}"
                            echo -e "${ReD} Both source and destination ports must be either${GrN} any ${ReD}or${GrN} all ${ReD}for the negation of a protocol.${DeF}"
                        fi
                    fi
                    if [[ "${Show_Protocol_Warning}" == "true" ]] && [[ "${LayerRule[$((i+2))]}" != "tcp" && "${LayerRule[$((i+2))]}" != "udp"  && "${LayerRule[$((i+2))]}" != "icmp" ]]; then
                        echo -e "${GrN}Warning in LayerRule${ReD} ${LayerRule[$((i+1))]} ${GrN}with protocol value:${ReD} ${LayerRule[$((i+2))]}${DeF}"
                        echo -e "${GrN} The firewall does not check for valid protocols, overriding with user input${DeF}"
                    fi
                fi
            fi
            if [  -n "${LayerRule[$((i+3))]}" ]; then
                srcIP="${LayerRule[$((i+3))]}"
                if [[ "${srcIP}" == "all" || "${srcIP}" == "any" ]]; then
                    srcIP=""
                else
                    testNegationIP result ${srcIP}
                    if [ "${result}" == "-0" ]; then
                        srcIP="-s ${srcIP}"
                    else
                        srcIP="! -s ${result}"
                    fi
                    # check for a valid ip/cidr
                    if [ "${result}" != "-0" ] && [[ !(${result} =~ $IPCIDRREGEX) ]]; then
                        echo -e "${ReD}Error in LayerRule${GrN} ${LayerRule[$((i+1))]} ${ReD}with source ip value:${GrN} ${LayerRule[$((i+3))]}${DeF}"
                    fi
                fi
            fi
            if [ -n "${LayerRule[$((i+4))]}" ]; then
                SrcP="${LayerRule[$((i+4))]}"
                if [[ "${SrcP}" == "all" || "${SrcP}" == "any" ]]; then
                    SrcP=""
                else
                    testNegationPort result ${SrcP}
                    if [ "${result}" == "-0" ]; then
                        SrcP="--sport ${SrcP}"
                    else
                        SrcP="! --sport ${result}"
                    fi
                    # check for a valid source port number
                    if [ "${result}" != "-0" ] && [[ !(${result} =~ $PortRangeREGEX) ]]; then
                        echo -e "${ReD}Error in LayerRule rule${GrN} ${LayerRule[$((i+1))]} ${ReD}with source port value:${GrN} ${LayerRule[$((i+4))]}${DeF}"
                    fi
                fi
            fi
            if [ -n "${LayerRule[$((i+5))]}" ]; then
                DestIP="${LayerRule[$((i+5))]}"
                if [[ "${DestIP}" == "all" || "${DestIP}" == "any" ]]; then
                    DestIP=""
                else
                    testNegationIP result ${DestIP}
                    if [ "${result}" == "-0" ]; then
                        DestIP="-d ${DestIP}"
                    else
                        DestIP="! -d ${result}"
                    fi
                    # check for a valid dest ip/cidr
                    if [ "${result}" != "-0" ] && [[ !(${result} =~ $IPCIDRREGEX) ]]; then
                        echo -e "${ReD}Error in LayerRule rule${GrN} ${LayerRule[$((i+1))]} ${ReD}with destination ip value:${GrN} ${LayerRule[$((i+5))]}${DeF}"
                    fi
                fi
            fi
            if [ -n "${LayerRule[$((i+6))]}" ]; then
                DestP="${LayerRule[$((i+6))]}"
                if [[ "${DestP}" == "all" || "${DestP}" == "any" ]]; then
                    DestP=""
                else
                    testNegationPort result ${DestP}
                    if [ "${result}" == "-0" ]; then
                        DestP="--dport ${DestP}"
                    else
                        DestP="! --dport ${result}"
                    fi
                    # check for a valid dest port number
                    if [ "${result}" != "-0" ] && [[ !(${result} =~ $PortRangeREGEX) ]]; then
                        echo -e "${ReD}Error in LayerRule rule${GrN} ${LayerRule[$((i+1))]} ${ReD}with destination port value:${GrN} ${LayerRule[$((i+6))]}${DeF}"
                    fi
                fi
            fi
            ##  ACTION  area
            action="${LayerRule[$((i+7))]}"
            prefix=''
            #${LayerRule[$((i+7))]}
            if [[ "$action" == "drop" ]]; then
                action="-j DROP"
            elif [[ "$action" == "accept" ]]; then
                action="-j ACCEPT"
            else
                # REJECT or LIMIT
                action=`echo "${LayerRule[$((i+7))]}" | awk '{print $1}'`
                p1=`echo "${LayerRule[$((i+7))]}" | awk '{print $2}'`
                ##
                # REJECT
                if [[ "$action" == "reject" ]]; then
                    sendBack="--reject-with"
                    case "${p1}" in
                        1|icmp-port-unreachable)
                            sendBack="${sendBack} icmp-port-unreachable"  ;;
                        2|icmp-net-unreachable)
                            sendBack="${sendBack} icmp-net-unreachable"   ;;
                        3|icmp-host-unreachable)
                            sendBack="${sendBack} icmp-host-unreachable"  ;;
                        4|icmp-proto-unreachable)
                            sendBack="${sendBack} icmp-proto-unreachable" ;;
                        5|icmp-net-prohibited)
                            sendBack="${sendBack} icmp-net-prohibited"    ;;
                        6|icmp-host-prohibited)
                            sendBack="${sendBack} icmp-host-prohibited"   ;;
                        7|tcp-reset)
                            sendBack="${sendBack} tcp-reset"              ;;
                        *)
                            echo -e -n "${ReD}Error in Reject Method '${GrN}${p1}${ReD}' in LayerRule: "
                            echo -n -e "  Layer:  "
                            echo -n -e            "${LayerRule[$((i+0))]},  Proto: '${LayerRule[$((i+2))]}',  "
                            echo -n -e            "src ip: '${LayerRule[$((i+3))]}',  src port: '${LayerRule[$((i+4))]}',  "
                            echo -n -e            "dest ip: '${LayerRule[$((i+5))]}',  dest port: '${LayerRule[$((i+6))]}',  action: '${LayerRule[$((i+7))]}',  "
                            echo    -e            "reject method: '${p1}'.${DeF}"
                            if [[ "${LayerRule[$((i+2))]}" == "TCP" ]]; then
                                echo -e "${GrN}Using method #7: tcp-reset.${DeF}"
                                sendBack="${sendBack} tcp-reset"
                            #elif [ "${LayerRule[$((i+2))]}" == "UDP" -o "${LayerRule[$((i+2))]}" == "udp" ]; then
                            else
                                echo -e "${GrN}Using method #1: icmp-port-unreachable.${DeF}"
                                sendBack="${sendBack} icmp-port-unreachable"
                            #else
                            #    echo -e "${GrN}Using method #8: echo-reply.${DeF}"
                            #    sendBack="${sendBack} "
                            fi
                    esac
                    action="-j REJECT ${sendBack}"
                # end REJECT
                ##
                # LIMIT
                elif [[ "$action" == "limit" ]]; then
                    p2=`echo "${LayerRule[$((i+7))]}" | awk '{print $3}'`
                    if  echo $p2 | grep "^[0-9]*$">aux ; then
                        if (( p2 > 0 )); then
                            action="-m limit --limit ${p1} --limit-burst ${p2} -j ACCEPT"
                        else
                            echo -e "${ReD}Error with LayerRule: $p2 is not a valid burst rate.${DeF}"
                            echo -e "${GrN}Applying rule without Burst Rate option.${DeF}"
                            action="-m limit --limit ${p1}  -j ACCEPT"
                        fi
                    else
                        echo -e "${ReD}Error with LayerRule: $p2 is not a valid burst rate.${DeF}"
                        echo -e "${GrN}Applying rule without Burst Rate option.${DeF}"
                        action="-m limit --limit ${p1}  -j ACCEPT"
                    fi

                # end LIMIT
                ## LOG
                elif [[ "$action" == "log" ]]; then
                    if [ -z "${p1}" ]; then
                        echo -e "${ReD}No log prefix specified with LayerRule's layer ${layer}.{Def}"
                        echo -e "${GrN}Using '${layer}' as log prefix!${DeF}"
                        prefix="${layer}"
                    fi
                    action="-j LOG"
                    LPsz=${#LogPrefix}
                    p1=${LayerRule[$((i+7))]:4:((32-LPsz))}
                    #action= "-j LOG --log-prefix \\\"${LogPrefix}${p1}\\\""

                # end LOG
                ## No ACTION
                elif [ "$action" == "" -o -z "$action" ]; then
                    action=""
                # end No Action
                ## error case
                else
                    echo -e "${ReD}Error with LayerRule${GrN} ${LayerRule[$((i+1))]}${ReD}\n Unknown action:${GrN} ${action}${ReD}; assigning Empty Action.${DeF}"
                    action=""
                fi  # end REJECT or LIMIT
            fi  # end  ACTION  area

            # slower-processing IF:  if [  ! -n "${LayerRule[$((i+2))]}" -a  -n "${LayerRule[$((i+4))]}"    -o    ! -n "${LayerRule[$((i+2))]}"  -a  -n "${LayerRule[$((i+6))]}"  ]; then
            if [ -z "${LayerRule[$((i+2))]}" ]  &&  [ -n "${LayerRule[$((i+4))]}" -o  -n "${LayerRule[$((i+6))]}" ]; then
                echo -e "${ReD}Error with LayerRule: "
                echo -n -e "  Layer:  "
                echo -n -e            "${LayerRule[$((i+0))]},  Proto: '${LayerRule[$((i+2))]}',  "
                echo -n -e            "src ip: '${LayerRule[$((i+3))]}',  src port: '${LayerRule[$((i+4))]}',  "
                echo    -e            "dest ip: '${LayerRule[$((i+5))]}',  dest port: '${LayerRule[$((i+6))]}',  action: '${LayerRule[$((i+7))]}'."
                echo -e "${GrN}Skipping rule.${DeF}"
                continue
            fi

# [ condition ] && (true || [ 1 == 1 ]) || false
            if [ "$action" == "-j LOG" ]; then
                # BS section for if action is LOG (the --log-prefix  above fails!)
                case "$1" in
                    101|102|103|104) # INPUT 1
                        $IPTABLES -t filter -I INPUT 1 ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} --log-prefix "${LogPrefix}${p1} " -m comment --comment "${desc}"
                        ;;
                    105|106|107|108|109|110|111|112|113|114|115|116|117|118|119) # INPUT append
                        $IPTABLES -t filter -A INPUT   ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} --log-prefix "${LogPrefix}${p1} " -m comment --comment "${desc}"
                        ;;
                    131| 19) # FORWARD 1
                        $IPTABLES -t filter -I FORWARD 1 ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} --log-prefix "${LogPrefix}${p1} " -m comment --comment "${desc}"
                        ;;
                    132|133|134|135|136|137|138|139|140)  # FORWARD append
                        $IPTABLES -t filter -A FORWARD ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} --log-prefix "${LogPrefix}${p1} " -m comment --comment "${desc}"
                        ;;
                    161|162|163| 29|30|31) # OUPUT 1
                        $IPTABLES -t filter -I OUTPUT 1 ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} --log-prefix "${LogPrefix}${p1} " -m comment --comment "${desc}"
                        ;;
                    164|165|166|167|168|169) # OUTPUT append
                        $IPTABLES -t filter -A OUTPUT  ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} --log-prefix "${LogPrefix}${p1} " -m comment --comment "${desc}"
                        ;;
                    *) # error case
                        echo -e "${ReD}LayerRule layer '${1}' is invalid.${DeF}"
                        ;;
                esac
                # end BS section for LOG action
            else
#                BSactionLOG=( )
#                if [ "$action" == "-j LOG" ]; then
#                 BSactionLOG=""
                case "$1" in
                    101|102|103|104| 1|2|3|4) # INPUT 1
                        $IPTABLES -t filter -I INPUT 1 ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} -m comment --comment "${desc}"
                        ;;
                    105|106|107|108|109|110|111|112|113|114|115|116|117|118|119| 5|6|7|8|9|10|11|12|13|14|15|16|17|18) # INPUT append
                        $IPTABLES -t filter -A INPUT   ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} -m comment --comment "${desc}"
                        ;;
                    131| 19) # FORWARD 1
                        $IPTABLES -t filter -I FORWARD 1 ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} -m comment --comment "${desc}"
                        ;;
                    132|133|134|135|136|137|138|139|140| 20|21|22|23|24|25|26|27|28)  # FORWARD append
                        $IPTABLES -t filter -A FORWARD ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} -m comment --comment "${desc}"
                        ;;
                    161|162|163| 29|30|31) # OUPUT 1
                        $IPTABLES -t filter -I OUTPUT 1 ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} -m comment --comment "${desc}"
                        ;;
                    164|165|166|167|168|169| 32|33|34|35|36|37) # OUTPUT append
                        $IPTABLES -t filter -A OUTPUT  ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} -m comment --comment "${desc}"
                        ;;
                    *) # error case
                        echo -e "${ReD}LayerRule layer '${1}' is invalid.${DeF}"
                        ;;
                esac
             fi # end if [ "$action" == "-j LOG" ]; then
            # unset the current elements just used - remove them from the LayerRule array
            #
            # Unix=('Debian' 'Red hat' 'Ubuntu' 'Suse' 'Fedora' 'UTS' 'OpenLinux');
            # pos=3
            # Unix=(${Unix[@]:0:$pos} ${Unix[@]:$(($pos + 1))})
            # echo ${Unix[@]}


## unset array (leaves empty item)
            unset LayerRule[$i]
            unset LayerRule[$i+1]
            unset LayerRule[$i+2]
            unset LayerRule[$i+3]
            unset LayerRule[$i+4]
            unset LayerRule[$i+5]
            unset LayerRule[$i+6]
            unset LayerRule[$i+7]
            LayerRule=("${LayerRule[@]}")
        fi  # if ${1} == $layer
        fi  # if (( $i % 8 == 0 ))
    done
    shopt -u nocasematch
} # end  InsertLayerRule (274 lines later...)

spoofTableSet=0
spoof_chain="INPUT"
function noSpoof {
    shopt -s nocasematch

      iface=""  # interface
    d_iface=""
    d_ifaceNLO="! -i lo"  # TODO: is it needed:  ! -i lo
    s_ip=""  # source IP
      ip=""  # our interface calculated subnet
    d_ip=""  # our interface IP
#    if [[ "$1" == "wan" ]]; then
#        continue
#    elif [[ "$1" == "iface" ]]; then
    if [[ "$1" == "iface" && "${2}" == "WAN" ]]; then
          iface=" ${3}"
        d_iface="-i ${3}"
        unset d_ifaceNLO
    elif [[ "$1" == "iface" && "${2}" == "LAN" ]]; then
        echo -e "${ReD}iface, LAN, ${3}${DeF}"
        return
    elif [[ "$1" == "ip" && "${2}" == "WAN" ]]; then
        #bcasts=`ifconfig | grep 'Bcast' | awk '{ print substr($3,7,16) }' | sort -u`
        #for x in $bcasts; do
        #    bcstSrc=`echo ${x} | awk -F"." '{print $1"."$2"."$3".0"}'`
        #    $IPTABLES -A INPUT -s ${bcstSrc}/24 -d ${x} -j ACCEPT -m comment --comment "LAN broadcast ${x}"
        #done

        # ${3} here is   IFACES[1] {ip}
        #ip=`echo ${3} | awk -F"." '{print $1"."$2"."$3".0/24"}'`
        ipOct=(`echo ${3} | awk -F"." '{print $1}'`)  #"\n"$2"\n"$3"\n"$4}'`
        ipOct+=(`echo ${3} | awk -F"." '{print $2}'`) #1  /8
        ipOct+=(`echo ${3} | awk -F"." '{print $3}'`) #2  /16
        #ipOct+=(`echo ${3} | awk -F"." '{print $4}'`) #3  /24
        cidr="24"
        if [[ "${ipOct[2]}" == "0" && "${ipOct[1]}" == "0" ]]; then
            cidr="8"
        elif [[ "${ipOct[2]}" == "0" ]]; then
            cidr="16"
        fi
        ip=" ${ipOct[0]}.${ipOct[1]}.${ipOct[2]}.0/${cidr}"
        d_ip="-d ${ip}"
    elif [[ "$1" == "ip" && "${2}" == "LAN" ]]; then
        $IPTABLES -A INPUT -m comment --comment "LAN MODE for $3 in noSpoof - this does nothing"
        return
    elif [[ "$1" == "lan" ]]; then
        $IPTABLES -A INPUT -m comment --comment "LAN MODE in noSpoof - this does nothing"
        return
    fi

    #echo -e "${ReD} doing the spoof rules${DeF}"
    echo " Appling IP Spoofing Rules for${iface}${ip}"


    if [[ "$spoofTableSet" == 0 ]]; then
        spoofTableSet=1
        #spoof_chain="INPUT"
        if [[ "$FancySpoofs" == "true" ]]; then
            spoof_chain="Spoofs"
            $IPTABLES -N ${spoof_chain}
            $IPTABLES -A INPUT -j ${spoof_chain}     -m comment --comment "WAN mode - IP Spoof checks"
        fi
    fi

   # Reject packets from RFC1918 class networks (i.e., spoofed)
    # 0.0.0.0 is inside the header when the source of the packet is unknown
    $IPTABLES -A ${spoof_chain} ${d_iface} -s 0.0.0.0/8 ${d_ip} -j DROP   -m comment --comment "block spoofing${iface}${ip}"
    $IPTABLES -A ${spoof_chain} ${d_iface} -d 0.0.0.0/8         -j DROP   -m comment --comment "block spoofing${iface}${ip}"

    $IPTABLES -A ${spoof_chain} ${d_iface}${d_ifaceNLO} -s 10.0.0.0/8 ${d_ip} -j DROP -m comment --comment "block spoofing${iface}${ip}"
    $IPTABLES -A ${spoof_chain} ${d_iface}${d_ifaceNLO} -s 127.0.0.0/8 ${d_ip} -j DROP -m comment --comment "block spoofing${iface}${ip}"
    $IPTABLES -A ${spoof_chain} ${d_iface}${d_ifaceNLO} -s 169.254.0.0/16 ${d_ip} -j DROP -m comment --comment "block spoofing${iface}${ip}"
    $IPTABLES -A ${spoof_chain} ${d_iface}${d_ifaceNLO} -s 172.16.0.0/12  ${d_ip} -j DROP -m comment --comment "block spoofing${iface}${ip}"
    $IPTABLES -A ${spoof_chain} ${d_iface}${d_ifaceNLO} -s 192.168.0.0/16 ${d_ip} -j DROP -m comment --comment "block spoofing${iface}${ip}"
    $IPTABLES -A ${spoof_chain} ${d_iface}${d_ifaceNLO} -s 192.168.1.0/24 ${d_ip} -j DROP -m comment --comment "block spoofing${iface}${ip}"

    ## 224.0.0.0/3  => 255.255.255.255  # need to allow (for whatever reason) 248.0.0.0 => 254.255.255.255.255
    ##  $IPTABLES -A INPUT -s 224.0.0.0/3      -j DROP
    ##  $IPTABLES -A INPUT -d 224.0.0.0/3      -j DROP

    ## 224.0.0.0/4  => 239.255.255.255
    $IPTABLES -A ${spoof_chain} ${d_iface} -s 224.0.0.0/4 ${d_ip} -j DROP   -m comment --comment "block spoofing${iface}${ip}"
    $IPTABLES -A ${spoof_chain} ${d_iface} -d 224.0.0.0/4         -j DROP   -m comment --comment "block spoofing${iface}${ip}"
    ## 239.255.255.0 =>239.255.255.255.255
    $IPTABLES -A ${spoof_chain} ${d_iface} -d 239.255.255.0/24    -j DROP   -m comment --comment "block spoofing${iface}${ip}"
    ## 240.0.0.0/5  => 247.255.255.255
    $IPTABLES -A ${spoof_chain} ${d_iface} -s 240.0.0.0/5 ${d_ip} -j DROP   -m comment --comment "block spoofing${iface}${ip}"
    $IPTABLES -A ${spoof_chain} ${d_iface} -d 240.0.0.0/5         -j DROP   -m comment --comment "block spoofing${iface}${ip}"
    # 248 - 254 allowed
    $IPTABLES -A ${spoof_chain} ${d_iface} -d 255.255.255.255     -j DROP   -m comment --comment "block spoofing${iface}${ip}"

    shopt -u nocasematch
}



###
case "$1" in
  start)
    echo
    echo " - Starting DTfw $VER - "
    echo
    shopt -s nocasematch
    # enable ip forwarding
    # echo 1 > /proc/sys/net/ipv4/ip_forward
    # mod probe ?

    # IPTables-Module
    $MODPROBE ip_tables
    $MODPROBE iptable_filter
    # Connection-Tracking-Module
    $MODPROBE ip_conntrack
    $MODPROBE ip_conntrack_irc
    $MODPROBE ip_conntrack_ftp
    if [[ "${EnableLog}" == "true" ]]; then
      $MODPROBE ipt_LOG

      # /etc/syslog.conf  :
      ### d.t firewall
      #kern.=debug    /var/log/firewall
      # /sbin/service syslog restart
      # /usr/sbin/service syslog restart  => unrecognized service

      #kern.warning   /bar/log/iptables.log
      # debian:
      #   /etc/init.d/sysklogd restart
      # redhat/centos:
      #   /etc/init.d/syslog restart
      #  --log-level 4: Level of logging. The level # 4 is for warning

      #disable console logging by commenting out this line in your syslog.conf
      #kern.* /dev/console
    else
        $MODPROBE -r ipt_LOG
        # warning not necessary #echo -e "${GrN}Logging disabled, there maybe errors/warnings in the script; ignore them.${DeF}"
    fi


    # Table Flush
    $IPTABLES -t filter -F
    $IPTABLES -t nat -F
    $IPTABLES -t mangle -F
    $IPTABLES -t nat -X
    $IPTABLES -t mangle -X
    $IPTABLES -X

    # allows all input while script starts incase some problems occur
    $IPTABLES -t filter -I INPUT 1 -j ACCEPT -m comment --comment "allow all while script starts"

    # Default-Policies
    ## set at END of start script, in case an error occurs and blocks SSH!


    # brute force chain
    BRUTEF="DropBrute"  # brute force table name
    $IPTABLES -N $BRUTEF
    $IPTABLES -A $BRUTEF -j LOG --log-prefix "${LogPrefix}brute forcer "
    $IPTABLES -A $BRUTEF -j DROP

    # Create Chain for Dymanic Hosts
    $IPTABLES -N dtfwdynamichosts

####  TODO: make this work -  bw rates
    BW_Rates="off"

    #  BW_Rates section
    ##
    # BW_REJECT-Chain
    REJECTER="BW_REJECT"
    #if [ "$BW_Rates" != "off" -a "$BW_Rates" != "OFF" -a "$BW_Rates" != "disabled" -a "$BW_Rates" != "DISABLED" ]; then
    if [[ "$BW_Rates" != "off" && "$BW_Rates" != "disabled" ]]; then
      $IPTABLES -N $REJECTER

     # BW_REJECT fill  rate/limits
### TODO: enable 'http/ftp redirect/vhost' for warning
      echo " Bandwith Rate of $BW_Rates enabled."
      $IPTABLES -A $REJECTER -p tcp -m limit --limit $BW_Rates -j LOG --log-prefix "${LogPrefix}REJECT TCP "
#      $IPTABLES -A $REJECTER -p tcp -j REJECT --reject-with tcp-reset
      $IPTABLES -A $REJECTER -p udp -m limit --limit $BW_Rates -j LOG --log-prefix "${LogPrefix}REJECT UDP "
#      $IPTABLES -A $REJECTER -p udp -j REJECT --reject-with icmp-port-unreachable
      $IPTABLES -A $REJECTER -p icmp -m limit --limit $BW_Rates -j LOG --log-prefix "${LogPrefix}DROP ICMP "
#      $IPTABLES -A $REJECTER -p icmp -j DROP
      $IPTABLES -A $REJECTER -m limit --limit $BW_Rates -j LOG --log-prefix "${LogPrefix}REJECT OTHER "
#      $IPTABLES -A $REJECTER -j REJECT --reject-with icmp-proto-unreachable

      $IPTABLES -A INPUT -j $REJECTER   -m comment --comment "for bandwidth overage"
      $IPTABLES -A OUTPUT -j $REJECTER

    fi
    ##
    #  end BW_Rates  section
#### end TODO: make this work - bw rates




    # DropTableName-Chain
    ## used for bad-packet dropping
    $IPTABLES -N ${DropTableName}
    #if [ "$LOG_Droped" == "true" -o "$LOG_Droped" == "TRUE" -o "$LOG_Droped" == "yes" ]; then
    if [[ "$LOG_Droped" == "true" || "$LOG_Droped" == "yes" ]]; then
      echo " Logging bad packets in Filter::${DropTableName}."
      $IPTABLES -A ${DropTableName} -j LOG --log-prefix "${LogPrefix}bad packet "   -m comment --comment "log bad data"
    fi
    $IPTABLES -A ${DropTableName} -j DROP   -m comment --comment "drop malformed data"




    InsertLayerRule "105"
    # connection tracking
    # related, or established, ACCEPT!
    $IPTABLES -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT -m comment --comment "connection tracking INPUT"


    InsertLayerRule "106"
# Block Spoofing - WAN ifaces ONLY!
    if [[ "$IFACES" == "WAN" && "${#IFACES[@]}" == 1 ]]; then
        noSpoof "WAN"
#        spoof_chain="INPUT"
#        if [[ "$FancySpoofs" == "true" ]]; then
#            spoof_chain="Spoofs"
#            $IPTABLES -N ${spoof_chain}
#            $IPTABLES -A INPUT -j ${spoof_chain}     -m comment --comment "WAN mode - IP Spoof checks"
#        fi
#        $IPTABLES -A ${spoof_chain} ! -i lo -s 10.0.0.0/8     -j DROP   -m comment --comment "block spoofing"
#        $IPTABLES -A ${spoof_chain} ! -i lo -s 127.0.0.0/8    -j DROP   -m comment --comment "block spoofing"
#        $IPTABLES -A ${spoof_chain} ! -i lo -s 169.254.0.0/16 -j DROP   -m comment --comment "block spoofing"
#        $IPTABLES -A ${spoof_chain} ! -i lo -s 172.16.0.0/12  -j DROP   -m comment --comment "block spoofing"
#        $IPTABLES -A ${spoof_chain} ! -i lo -s 192.168.0.0/16 -j DROP   -m comment --comment "block spoofing"
#
#       # Reject packets from RFC1918 class networks (i.e., spoofed)
#        #$IPTABLES -A INPUT -s 10.0.0.0/8     -j DROP
#        #$IPTABLES -A INPUT -s 127.0.0.0/8    -j DROP
#        #$IPTABLES -A INPUT -s 172.16.0.0/12  -j DROP
#        #$IPTABLES -A INPUT -s 169.254.0.0/16 -j DROP
#
#        $IPTABLES -A ${spoof_chain} -s 0.0.0.0/8        -j DROP   -m comment --comment "block spoofing"
#        $IPTABLES -A ${spoof_chain} -d 0.0.0.0/8        -j DROP   -m comment --comment "block spoofing"
#
#        ## 224.0.0.0/3  => 255.255.255.255
#        ##  $IPTABLES -A INPUT -s 224.0.0.0/3      -j DROP
#        ##  $IPTABLES -A INPUT -d 224.0.0.0/3      -j DROP
#
#        ## 224.0.0.0/4  => 239.255.255.255
#        $IPTABLES -A ${SPOOF_CHAIN} -s 224.0.0.0/4      -j DROP   -m comment --comment "block spoofing"
#        $IPTABLES -A ${spoof_chain} -d 224.0.0.0/4      -j DROP   -m comment --comment "block spoofing"
#        $IPTABLES -A ${spoof_chain} -d 239.255.255.0/24 -j DROP   -m comment --comment "block spoofing"
#        ## 240.0.0.0/5  => 247.255.255.255
#        $IPTABLES -A ${spoof_chain} -s 240.0.0.0/5      -j DROP   -m comment --comment "block spoofing"
#        $IPTABLES -A ${spoof_chain} -d 240.0.0.0/5      -j DROP   -m comment --comment "block spoofing"
#        # 248 - 254 allowed
#        $IPTABLES -A ${spoof_chain} -d 255.255.255.255  -j DROP   -m comment --comment "block spoofing"


    #else  # IFACE is LAN or an array >= 1
    #elif [[ "$IFACES" != "LAN" && "$IFACES" != "lan" ]]; then
    elif [[ "${#IFACES[@]}" > 1 ]]; then
        if (( ${#IFACES[@]} % 2 == 0 )); then
            ## do a quick check for LAN and WAN for same iface, unset the WAN if found
            for (( i=0; i< ${#IFACES[@]}; i=i+2 )); do
                for (( j=i+2; j< ${#IFACES[@]}; j=j+2 )); do
                    # find duplicates
                    if [[ "${IFACES[i]}" == "${IFACES[j]}" && "${IFACES[((i+1))]}" == "${IFACES[((j+1))]}"  ]]; then
                        echo -e "${GrN}Warning in IFACES, duplicates found:${ReD} ${IFACES[i]} ${IFACES[((i+1))]}${DeF}"
                        unset IFACES[$j]
                        unset IFACES[$((j+1))]
                    fi
                    # find WAN on same iface as LAN
                    if [[ "${IFACES[i]}" == "WAN" && "${IFACES[j]}" == "LAN" && "${IFACES[((i+1))]}" == "${IFACES[((j+1))]}"  ]]; then
                        echo -e "${GrN}Warning in IFACES, WAN and LAN found for one interface:${ReD} ${IFACES[i]} ${IFACES[((i+1))]}${GrN},${ReD} ${IFACES[j]} ${IFACES[((j+1))]}${DeF}"
                        # unsets the WAN
                        unset IFACES[$i]
                        unset IFACES[$((i+1))]
                    fi
                    # find LAN on same iface as WAN
                    if [[ "${IFACES[i]}" == "LAN" && "${IFACES[j]}" == "WAN" && "${IFACES[((i+1))]}" == "${IFACES[((j+1))]}"  ]]; then
                        echo -e "${GrN}Warning in IFACES, LAN and WAN found for one interface:${ReD} ${IFACES[i]} ${IFACES[((i+1))]}${GrN},${ReD} ${IFACES[j]} ${IFACES[((j+1))]}${DeF}"
                        # unsets the WAN
                        unset IFACES[$j]
                        unset IFACES[$((j+1))]
                    fi
                done
            done
            # yup, trying to clean up the array fubar's things
            ## IFACES=("#{IFACES[@]}")

            # initiate the spoof-rules for WAN
            for (( i=0; i< ${#IFACES[@]}; i++ )); do
                if (( $i %2  == 0 )); then
                    if [[ "${IFACES[$((i+0))]}" == "WAN" ]]; then  # || "${IFACES[$((i+0))]}" == "LAN" ]]; then
                        #echo "first is WAN"
                        if [[ ${IFACES[$((i+1))]} =~ $IPCIDRREGEX ]]; then
                            noSpoof "ip" "${IFACES[$((i+0))]}" "${IFACES[$((i+1))]}"
                        else
                            noSpoof "iface" "${IFACES[$((i+0))]}" "${IFACES[$((i+1))]}"
                        fi
                    # if reverse syntax
                    #elif [[ "${IFACES[$((i+1))]}" == "WAN" ]]; then
                    #    #echo "second is WAN"
                    #    if [[ ${IFACES[$((i+0))]} =~ $IPCIDRREGEX ]]; then
                    #        noSpoof "ip" "${IFACES[$((i+1))]}" "${IFACES[$((i+0))]}"
                    #    else
                    #        noSpoof "iface" "${IFACES[$((i+1))]}" "${IFACES[$((i+0))]}"
                    #    fi
                    fi
                fi
            done
        else
            echo -e "${ReD}Error in IFACES. There is an odd amount of parameters:${GrN} ${#IFACES[@]}${DeF}"
        fi
    fi


#    elif [ "$IFACES" == "LAN" -o "$IFACES" == "lan" ]; then
#       # ifconfig | grep -s "eth1" -A 1 | grep -s "inet addr" | awk '{print substr($2,6,15)}'
#       # ifconfig | grep -s "eth1" -A 1 | awk '/addr:/ { print substr($2,6,15)  }'
#       # ifconfig | grep 'Bcast' | awk '{ print substr($3,7,16) }' | sort -u
#       # ifconfig | grep 'Bcast' | awk '{print $3}' | cut -f2 -d ':' | sort -u
#        # d 192.168.1.255  s <rand>   udp s + d  631:   Inet Printing Proto IPP
#        # 224.0.0.251:5353  -> mDNS - multicast DNS address (or its IPv6 equivalent [FF02::FB]:5353) - sent to
#        #  sent from udp port 5353 signals 'presence of a fully-compliant Multicast DNS Querier'
#        # 1 2 or blocks of 4 +1  broadcast
#        #wake on lan
#        #RIP
#        # intel router switching
#        # 10 routers that dynamically route, then use bcast
#        if [ "$Allow_lan_inBCast" == "true" -o "$Allow_lan_inBCast" == "TRUE" ]; then
#            bcasts=`ifconfig | grep 'Bcast' | awk '{ print substr($3,7,16) }' | sort -u`
#            for x in $bcasts; do
#                bcstSrc=`echo ${x} | awk -F"." '{print $1"."$2"."$3".0"}'`
#               $IPTABLES -A INPUT -s ${bcstSrc}/24 -d ${x} -j ACCEPT -m comment --comment "LAN broadcast ${x}"
##echo "                $IPTABLES -A INPUT -s ${bcstSrc}/24 -d ${x} -j ACCEPT -m comment --comment \"LAN broadcast ${x}\""
#            done
#        fi
#
#        ## TODO: select good vs bad SPOOFS and drop bad ones
#
#        #SPOOF_IPS+=("0.0.0.0/8")
#        #SPOOF_IPS+=("10.0.0.0/8")
#        #SPOOF_IPS+=("127.0.0.0/8")
#        #SPOOF_IPS+=("172.16.0.0/12")
#        #SPOOF_IPS+=("192.168.0.0/16")
#        #SPOOF_IPS+=("224.0.0.0/3")
#    else # the $IFACE is an array with several presets, or a typo
#
#        for (( i=0; i< ${#IFACE[@]}; i++ ))
#        do
#            if (( $i %2 == 0 )); then
#                echo "${ReD}iface array declared${DeF}"
#            fi
#        done
##    for (( i=0; i< ${#BruteForce[@]}; i++ ))
##    do
##      if (( $i % 2 == 0 )); then
##        $IPTABLES -A INPUT -p tcp --dport ${BruteForce[$i]} \
##          -m conntrack --ctstate NEW -m recent --set --name "BF_${BruteForce[$((i+1))]}"  \
##          -m comment --comment "${BruteForce[$((i+1))]}"
##        $IPTABLES -A INPUT -p tcp --dport ${BruteForce[$i]} \
##          -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 8 --rttl --name "BF_${BruteForce[$((i+1))]}" -j ${BRUTEF} \
##          -m comment --comment "${BruteForce[$((i+1))]}"
##      fi
##    done
#    fi





    InsertLayerRule "107"
    if [[ "$IFACES" == "LAN" ]]; then
        echo ' Allowing Localhost'
    #Allow localhost.  # whats origin of this ?
        $IPTABLES -A INPUT -t filter -s 127.0.0.1 -j ACCEPT -m comment --comment "allow localhost LAYER RULE 7"
    fi

    InsertLayerRule "108"
    # Loopback-Network-Communication allow
    $IPTABLES -A INPUT -i lo -j ACCEPT    -m comment --comment "loopback iface inbound"





    # a small section for OUTPUT chain in FILTER table
    ###
    #InsertLayerRule "162"  TODO 
    ### loop for WHITELIST ( use WHITELIST file (end of file);  TODO: AND allow a second file AND script array )
    ## TODO
    #InsertLayerRule "163"  TODO 
    ### loop for Outbound BLACKLIST ( separate list as INPUT, AND array )

    InsertLayerRule "164"
    # giant if => used to check outbound packets for corruption
    OUT_BAD_PAC_DESC=()
    OUT_NEW_STATE=()
    OUT_NEW_DESC=()
    if [[ "$Block_Corrupt_Outbound" == "false" || "$Block_Corrupt_Outbound" == "0" || "$Block_Corrupt_Outbound" == "no" ]]; then
        # connection tracking
        $IPTABLES -A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT -m comment --comment "connection tracking OUTPUT"
        OUT_BAD_PAC_DESC="corrupt packets OUTPUT"
        OUT_NEW_STATE="NEW"
        OUT_NEW_DESC="new connections OUTPUT"
    else
        OUT_BAD_PAC_DESC="force check corrupt packets OUTPUT"
        OUT_NEW_STATE="NEW,ESTABLISHED,RELATED"
        OUT_NEW_DESC="new and connection tracking OUTPUT"
    fi # end  giant if, outbound packet corruption

    InsertLayerRule "165"
    # accept lo iface OUTPUT
    $IPTABLES -A OUTPUT -o lo -j ACCEPT   -m comment --comment "loopback iface outbound"

    InsertLayerRule "166"
    # Corrupt Packet drop
    $IPTABLES -A OUTPUT -m conntrack --ctstate INVALID -j DROP -m comment --comment "${OUT_BAD_PAC_DESC}"

    InsertLayerRule "167"
    # DROP/REJECT rules [TODO] - destination port blocking (source IP blocking) - iface?
    ### loop for blocking outbound

    InsertLayerRule "168" # new+connection tracking - output
    # accept otherwise
    $IPTABLES -A OUTPUT -m conntrack --ctstate ${OUT_NEW_STATE} -j ACCEPT -m comment --comment "${OUT_NEW_DESC}"
    InsertLayerRule "169" # log bogus outward connections (last rule)
    ###
    # end OUTPUT section




    # section for FORWARD chain in FILTER table
    ###
    InsertLayerRule "132"
    # connection tracking
    # related, or established, ACCEPT!
    $IPTABLES -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT -m comment --comment "connection tracking FORWARD"

    InsertLayerRule "133"
    # Force ACCEPT Rules [TODO]

    # unclean data (attacks, corrupt, ect) - FORWARD chain
    ###
    InsertLayerRule "134"
    # Corrupt Packet drop
    $IPTABLES -A FORWARD -m conntrack --ctstate INVALID -j DROP   -m comment --comment "corrupt packets FORWARD"
    InsertLayerRule "135"
    # Stealth Scans etc. DROPpen
    # Non Flags
    $IPTABLES -A FORWARD -p tcp --tcp-flags ALL NONE -j $DropTableName   -m comment --comment "stealth scans"
    # SYN and FIN
    $IPTABLES -A FORWARD -p tcp --tcp-flags SYN,FIN SYN,FIN -j $DropTableName   -m comment --comment "SYN and FIN" 
    # SYN and RST set at same time
    $IPTABLES -A FORWARD -p tcp --tcp-flags SYN,RST SYN,RST -j $DropTableName   -m comment --comment "SYN and RST at same time"
    # FIN and RST set at same time
    $IPTABLES -A FORWARD -p tcp --tcp-flags FIN,RST FIN,RST -j $DropTableName   -m comment --comment "FIN and RST at same time"
    # FIN without ACK
    $IPTABLES -A FORWARD -p tcp --tcp-flags ACK,FIN FIN -j $DropTableName   -m comment --comment "FIN w-o ACK"
    # PSH without ACK
    $IPTABLES -A FORWARD -p tcp --tcp-flags ACK,PSH PSH -j $DropTableName   -m comment --comment "PSH w-o ACK"
    # URG without ACK
    $IPTABLES -A FORWARD -p tcp --tcp-flags ACK,URG URG -j $DropTableName   -m comment --comment "URG w-o ACK"
# added FORWARDs - copyied from INPUT
    # XMAS packets
    $IPTABLES -A FORWARD -p tcp --tcp-flags ALL ALL -j $DropTableName    -m comment --comment "XMAS packet drop"
    # Drop Null Packets
    $IPTABLES -A FORWARD -p tcp --tcp-flags ALL NONE -j $DropTableName   -m comment --comment "NULL packet drop"
    # more badflags  http://pikt.org/pikt/samples/iptables_tcp_flags_programs.cfg.html
    $IPTABLES -A FORWARD -p tcp --tcp-flags ALL FIN,PSH,URG -j $DropTableName          -m comment --comment "more badflags"
    $IPTABLES -A FORWARD -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j $DropTableName      -m comment --comment "more badflags"
    $IPTABLES -A FORWARD -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j $DropTableName  -m comment --comment "more badflags"
    # pettingers.org/code/firewall.html
    $IPTABLES -A FORWARD ! -i lo -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j $DropTableName -m comment --comment "from pettingers.org"
    # Force SYN packets check
    $IPTABLES -A FORWARD -p tcp ! --syn -m conntrack --ctstate NEW -j $DropTableName  -m comment --comment "force SYN packets check"
    InsertLayerRule "136"
    # Force Fragments packets check
    $IPTABLES -A FORWARD -f -j $DropTableName   -m comment --comment "force fragment packet check"
    ###
    # end unclean data - OUTPUT chain

    InsertLayerRule "137"
    ### Other flood protections - limit DoS
    # limits rate in FORWARD
    # http://netfilter.org/documentation/HOWTO/packet-filtering-HOWTO-7.html
        iptables -A FORWARD -p tcp --syn -m limit --limit 1/s -j ACCEPT
        iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s -j ACCEPT
        iptables -A FORWARD -p icmp --icmp-type echo-request -m limit --limit 1/s -j ACCEPT
    # TODO: research wtf those 3 lines mean
    for (( i=0; i< ${#OTHER_FLOODS[@]}; i++ ))
    do
      if (( $i % 2 == 0 )); then
        OFP=( )
        if [[ "${OTHER_FLOODS[$i]}"   == "syn flood" ]]; then
          OFP="-p tcp --syn -m limit"
        elif [[ "${OTHER_FLOODS[$i]}" == "furtive port scanner" ]]; then
          OFP="-p tcp --tcp-flags SYN,ACK,FIN,RST RST"
        elif [[ "${OTHER_FLOODS[$i]}" == "ping of death" ]]; then
          OFP="-p icmp --icmp-type echo-request"
        else
          echo -e "${ReD}there is no rule type for OTHER_FLOODS=(\"${OTHER_FLOODS[$i]}\" \"${OTHER_FLOODS[$((i+1))]}\"), skipping it.${DeF}"
        fi

        if [ "${OFP}" != "" ]; then
          $IPTABLES -A FORWARD ${OFP} -m limit --limit ${OTHER_FLOODS[$((i+1))]} -j ACCEPT   -m comment --comment "limit DoS ${OTHER_FLOODS[$i]}"
        fi
      fi
    done

    InsertLayerRule "138"
    ## TODO: good-packet accept rules (PD, PSD, PISD, PID)
    ## TODO!

    InsertLayerRule "139"
    # allow FORWARD after all them bad packet checks
    $IPTABLES -A FORWARD ! -i ppp0 -m conntrack --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT   -m comment --comment "connection tracking FORWARD"

    InsertLayerRule "140" # log bogus forward connections (last rule)
    ###
    # end FORWARD chain in FILTER table



    #
    ## FILTER INPUT chain
    # unclean data (attacks, corrupt, ect) - INPUT chain
    ###
    InsertLayerRule "109"
    invalid_frag_chain="INPUT"
    if [[ "$FancyInvalid_Frag" == "true" || "$FancyInvalid_Frag" == "TRUE" ]]; then
        invalid_frag_chain="InvalidFrag"
        $IPTABLES -N $invalid_frag_chain
        $IPTABLES -A INPUT -j $invalid_frag_chain     -m comment --comment "check for Invalid or Fragmented Packets"
    fi

    # Corrupt Packet drop
    $IPTABLES -A $invalid_frag_chain -m conntrack --ctstate INVALID -j $DropTableName     -m comment --comment "invalid packets INPUT"
    # Force Fragments packets check
    $IPTABLES -A $invalid_frag_chain -f -j $DropTableName     -m comment --comment "force fragment packet check"


    InsertLayerRule "110"
    uncleanChainIN="INPUT"
    if [[ "$FancyBadTCP" == "true" || "$FancyBadTCP" == "TRUE" ]]; then
        uncleanChainIN="badTCPIN"
        $IPTABLES -N $uncleanChainIN
        $IPTABLES -A INPUT -p tcp -j $uncleanChainIN     -m comment --comment "check for invalid tcp packets"
    fi
    # Stealth Scans etc. DROPpen
    # Non Flags
    $IPTABLES -A $uncleanChainIN -p tcp --tcp-flags ALL NONE -j $DropTableName     -m comment --comment "stealth scans"
    # SYN and FIN
    $IPTABLES -A $uncleanChainIN -p tcp --tcp-flags SYN,FIN SYN,FIN -j $DropTableName     -m comment --comment "SYN and FIN" 
    # SYN and RST set at same time
    $IPTABLES -A $uncleanChainIN -p tcp --tcp-flags SYN,RST SYN,RST -j $DropTableName     -m comment --comment "SYN and RST at same time"
    # FIN and RST set at same time
    $IPTABLES -A $uncleanChainIN -p tcp --tcp-flags FIN,RST FIN,RST -j $DropTableName     -m comment --comment "FIN and RST at same time"
    # FIN without ACK
    $IPTABLES -A $uncleanChainIN -p tcp --tcp-flags ACK,FIN FIN -j $DropTableName     -m comment --comment "FIN w-o ACK"
    # PSH without ACK
    $IPTABLES -A $uncleanChainIN -p tcp --tcp-flags ACK,PSH PSH -j $DropTableName     -m comment --comment "PSH w-o ACK"
    # URG without ACK
    $IPTABLES -A $uncleanChainIN -p tcp --tcp-flags ACK,URG URG -j $DropTableName     -m comment --comment "URG w-o ACK"
    # XMAS packets
    $IPTABLES -A $uncleanChainIN -p tcp --tcp-flags ALL ALL -j $DropTableName    -m comment --comment "XMAS packet drop"
    # Drop Null Packets
    $IPTABLES -A $uncleanChainIN -p tcp --tcp-flags ALL NONE -j $DropTableName   -m comment --comment "NULL packet drop"
    # more badflags  http://pikt.org/pikt/samples/iptables_tcp_flags_programs.cfg.html
    $IPTABLES -A $uncleanChainIN -p tcp --tcp-flags ALL FIN,PSH,URG -j $DropTableName          -m comment --comment "more badflags"
    $IPTABLES -A $uncleanChainIN -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j $DropTableName      -m comment --comment "more badflags"
    $IPTABLES -A $uncleanChainIN -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j $DropTableName  -m comment --comment "more badflags"
    # pettingers.org/code/firewall.html
    $IPTABLES -A $uncleanChainIN ! -i lo -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j $DropTableName -m comment --comment "from pettingers.org"
    # Force SYN packets check
    $IPTABLES -A $uncleanChainIN -p tcp ! --syn -m conntrack --ctstate NEW -j $DropTableName   -m comment --comment "force SYN packets check"
    ###
    # end unclean data - INPUT chain




    InsertLayerRule "112"
    # Drop all packets to port 111 except those from localhost
    $IPTABLES -A INPUT ! -s 127.0.0.0/8 -p tcp --dport 111 -j DROP   -m comment --comment "RPC related, allow only localhost"

    # kill off identd quick
    $IPTABLES -A INPUT -p tcp ! -i lo   --dport 113 -j REJECT --reject-with tcp-reset   -m comment --comment "kill off identd quick"

    # Don't log route packets coming from routers - too much logging
    $IPTABLES -A INPUT -p udp ! -i lo   --dport 520 -j REJECT   -m comment --comment "do not log route packets from routers"



    InsertLayerRule "113"

    # Block Ping
    if [[ $"${Block_Ping[0]}" == "false" || "${Block_Ping[0]}" == "no" ]]; then
      $IPTABLES  -A INPUT -p icmp --icmp-type echo-request -j ACCEPT   -m comment --comment "allow ping"
      echo " Ping (ipv4): allowed."
    elif [[ "${Block_Ping[0]}" == "drop" ]]; then
      $IPTABLES  -A INPUT -p icmp --icmp-type echo-request -j DROP     -m comment --comment "drop ping"
      echo " Ping (ipv4): dropped."
    elif [[ "${Block_Ping[0]}" == "reject" ]]; then
      sendBack=( )
      case "${Block_Ping[1]}" in
          1|icmp-port-unreachable)
              sendBack="icmp-port-unreachable"  ;;
          2|icmp-net-unreachable)
              sendBack="icmp-net-unreachable"   ;;
          3|icmp-host-unreachable)
              sendBack="icmp-host-unreachable"  ;;
          4|icmp-proto-unreachable)
              sendBack="icmp-proto-unreachable" ;;
          5|icmp-net-prohibited)
              sendBack="icmp-net-prohibited"    ;;
          6|icmp-host-prohibited)
              sendBack="icmp-host-prohibited"   ;;
          *)
              echo -e "${ReD}Block Ping Reject bounce-back-error typo: \"${Block_Ping[1]}\", using \"icmp-port-unreachable\".${DeF}"
              sendBack="icmp-port-unreachable"  ;;
      esac
      $IPTABLES -A INPUT -p icmp --icmp-type echo-request -j REJECT --reject-with ${sendBack} -m comment --comment "reject ping"
      echo " Ping (ipv4): Reject with ${sendBack}."
    ### ICMP Rate limits (elimiates some SMURF packets)
    elif [[ "${Block_Ping[0]}" == "limit" ]]; then
        # dont know what the first two lines do - TODO: research wtf those 2 lines mean
        $IPTABLES -A INPUT -p icmp -m icmp --icmp-type address-mask-request -j DROP
        $IPTABLES -A INPUT -p icmp -m icmp --icmp-type timestamp-request -j DROP
        $IPTABLES -A INPUT -p icmp -m icmp -m limit --limit ${Block_Ping[1]} --limit-burst ${Block_Ping[2]} -j ACCEPT
        echo " Ping: Limited at ${Block_Ping[1]} with burst of ${Block_Ping[2]}."
    fi









# HTTP flood check
# http://lists.netfilter.org/pipermail/netfilter/2003-June/044762.html
    $IPTABLES -N flood-chk
    $IPTABLES -A INPUT -p tcp --dport 80 --syn -j flood-chk -m comment --comment "HEEEEERRRRRRRRRR"
    $IPTABLES -A flood-chk -m limit --limit 1/sec --limit-burst 2 -j RETURN
    $IPTABLES -A flood-chk -j LOG --log-prefix "${LogPrefix}flood packet"
    $IPTABLES -A flood-chk -j DROP

    InsertLayerRule "114"  # INPUT flood protections - TODO
    ### Other flood protections - limit DoS [ Implemented in FORWARD section ]
    # limits rate in FORWARD - fuction here for future FLOOD additions (for INPUT table)
    for (( i=0; i< ${#OTHER_FLOODS[@]}; i++ ))
    do
      if (( $i % 2 == 0 )); then
        OFP=( )
        if [ "${OTHER_FLOODS[$i]}"   == "syn flood" ]; then
          OFP="-p tcp --syn -m limit"
        elif [ "${OTHER_FLOODS[$i]}" == "furtive port scanner" ]; then
          OFP="-p tcp --tcp-flags SYN,ACK,FIN,RST RST"
        elif [ "${OTHER_FLOODS[$i]}" == "ping of death" ]; then
          OFP="-p icmp --icmp-type echo-request"
        else
          echo -e "${ReD}there is no rule type for OTHER_FLOODS=(\"${OTHER_FLOODS[$i]}\" \"${OTHER_FLOODS[$((i+1))]}\"), skipping it.${DeF}"
        fi

        if [ "${OFP}" != "" ]; then
          $IPTABLES -A FORWARD ${OFP} -m limit --limit ${OTHER_FLOODS[$((i+1))]} -j ACCEPT   -m comment --comment "limit DoS ${OTHER_FLOODS[$i]}"
        fi
      fi
    done



    InsertLayerRule "115"
    # Block Brute Force
    BF_chain="INPUT"
    if [[ "$FancyBruteForce" == "true" || "$FancyBruteForce" == "TRUE" ]]; then
        BF_chain="BruteForce"
        $IPTABLES -N $BF_chain
        $IPTABLES -A INPUT -j ${BF_chain}     -m comment --comment "Brute Force Check"
    fi
    for (( i=0; i< ${#BruteForce[@]}; i++ ))
    do
      if (( $i % 2 == 0 )); then
        $IPTABLES -A ${BF_chain} -p tcp --dport ${BruteForce[$i]} \
          -m conntrack --ctstate NEW -m recent --set --name "BF_${BruteForce[$((i+1))]}"  \
          -m comment --comment "${BruteForce[$((i+1))]}"
        $IPTABLES -A ${BF_chain} -p tcp --dport ${BruteForce[$i]} \
          -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 8 --rttl --name "BF_${BruteForce[$((i+1))]}" -j ${BRUTEF} \
          -m comment --comment "${BruteForce[$((i+1))]}"
      fi
    done



    InsertLayerRule "116"
### _SRV section

    SRV_chain="INPUT"
    if [[ "$FancyServices" == "true" || "$FancyServices" == "TRUE" ]]; then
        SRV_chain="Services"
        $IPTABLES -N $SRV_chain
        $IPTABLES -A INPUT -j ${SRV_chain}     -m comment --comment "Services"
    fi

### general services (allow all sources ips):port:desc
### specific:  Proto,  Dest port
#   PD_SRV+=( "<DESC>" "<tcp|udp|both>" "<PORT|all>" )
#    shopt -s nocasematch
    sz_PD=${#PD_SRV[@]}
    for (( i=0; i< sz_PD; i++ ))
    do
      if (( $i % 3 == 0 )); then
        dport="${PD_SRV[$((i+2))]}"
        if [[ "${dport}" == "all" || "${dport}" == "any" ]]; then
            dport=""
        else
            testNegationPort result ${dport}
            if [ "${result}" == "-0" ]; then
                dport="--dport ${dport}"
            else
                dport="! --dport ${result}"
            fi
            # check dport for a valid port number
            if [ "${result}" != "-0" ] && [[ !(${result} =~ $PortRangeREGEX) ]]; then 
                echo -e "${ReD}Error in PD_SRV rule${GrN} ${PD_SRV[$i]} ${ReD}with destination port value:${GrN} ${PD_SRV[$((i+2))]}${DeF}"
            fi
        fi

        proto="${PD_SRV[$((i+1))]}"
        if [[ "${proto}" != "any" && "${proto}" != "all"  ]]; then
            if [[ "${proto}" == "tcp" ]]; then
                proto="tcp"
            elif [[ "${proto}" == "udp" ]]; then
                proto="udp"
            elif [[ "${proto}" == "both" ]]; then
                $IPTABLES -t filter -A ${SRV_chain} -m conntrack --ctstate NEW -p tcp      ${dport} -j ACCEPT -m comment --comment "${PD_SRV[$i]} tcp"
                proto="udp"
            else
                if [[ "${Show_Protocol_Warning}" == "true" ]]; then
                echo -e "${GrN}Warning in PD_SRV rule${ReD} ${PD_SRV[$i]} ${GrN}with protocol value:${ReD} ${PD_SRV[$((i+1))]}${DeF}"
                echo -e "${GrN} The firewall does not check for valid protocols, overriding with user input${DeF}"
                fi
            fi
        #elif [[ "${proto}" == "any" && "${dport}" != "" ]]; then
        else
            proto="all"
            if [[ "${dport}" != "" ]]; then
                echo -e "${ReD}Error in PD_SRV rule${GrN} ${PD_SRV[$i]} ${ReD}with destination port value${GrN} ${PD_SRV[$((i+1))]}"
                echo -e "${ReD} Unable to assign a port to ${GrN} any ${ReD}or${GrN} all ${ReD}protocols.${DeF}"
            fi
        fi


        $IPTABLES   -t filter -A ${SRV_chain} -m conntrack --ctstate NEW -p ${proto} ${dport} -j ACCEPT -m comment --comment "${PD_SRV[$i]} ${proto}"

## unset array (leaves empty item)
        unset PD_SRV[$i]
        unset PD_SRV[$i+1]
        unset PD_SRV[$i+2]

      fi
    done


### specific:  Proto,  src IP,  Dest port
#   PID_SRV+=( "<DESC>" "<tcp|udp|both>" "<src ip|all>" "<dst port | all>"
    sz_PID=${#PID_SRV[@]}
    for (( i=0; i< sz_PID; i++ ))
    do
      if (( $i % 4 == 0 )); then
        dport="${PID_SRV[$((i+3))]}"
        if [[ "${dport}" == "any" || "${dport}" == "all" ]]; then
            dport=""
        else
            testNegationPort result ${dport}
            if [ "${result}" == "-0" ]; then
                dport="--dport ${dport}"
            else
                dport="! --dport ${result}"
            fi
            # check dport for a valid port number
            if [ "${result}" != "-0" ] && [[ !(${result} =~ $PortRangeREGEX) ]]; then
                echo -e "${ReD}Error in PID_SRV rule${GrN} ${PID_SRV[$i]} ${ReD}with destination port value:${GrN} ${PID_SRV[$((i+3))]}${DeF}"
            fi
        fi

        srcIP=${PID_SRV[$((i+2))]}
        if [[ "${srcIP}" == "any" || "${srcIP}" == "all" ]]; then
            srcIP=""
        else
            testNegationIP result ${srcIP}
            if [ "${result}" == "-0" ]; then
                srcIP="-s ${srcIP}"
            else
                srcIP="! -s ${result}"
            fi
            # check for a valid ip/cidr
            if [ "${result}" != "-0" ] && [[ !(${result} =~ $IPCIDRREGEX) ]]; then
                echo -e "${ReD}Error in PID_SRV rule${GrN} ${PID_SRV[$1]} ${ReD}with source ip value:${GrN} ${PID_SRV[$((i+2))]}${DeF}"
            fi
        fi
        proto="${PID_SRV[$((i+1))]}"
        if [[ "${proto}" != "any" && "${proto}" != "all" ]]; then
            if [[ "${proto}" == "tcp" ]]; then
                proto="tcp"
            elif [[ "${proto}" == "udp" ]]; then
                proto="udp"
            elif [[ "${proto}" == "both" ]]; then
                $IPTABLES -t filter -A ${SRV_chain} -m conntrack --ctstate NEW ${srcIP} -p tcp \
                    ${dport} -j ACCEPT -m comment --comment "${PID_SRV[$i]} tcp"
                proto="udp"
            else
                if [[ "${Show_Protocol_Warning}" == "true" ]]; then
                    echo -e "${GrN}Warning in PID_SRV rule${ReD} ${PID_SRV[$i]} ${GrN}with protocol value:${ReD} ${PID_SRV[$((i+1))]}${DeF}"
                    echo -e "${GrN} The firewall does not check for valid protocols, overriding with user input${DeF}"
                fi
            fi
        else
            proto="all"
            if [[ "${dport}" != "" ]]; then
                echo -e "${ReD}Error in PID_SRV rule${GrN} ${PID_SRV[$i]} ${ReD}with destination port value${GrN} ${PID_SRV[$((i+3))]}"
                echo -e "${ReD} Unable to assign a port to${GrN} any ${ReD}or${GrN} all ${ReD}protocols.${DeF}"
            fi
        fi

        $IPTABLES   -t filter -A ${SRV_chain} -m conntrack --ctstate NEW ${srcIP} -p ${proto} \
            ${dport} -j ACCEPT -m comment --comment "${PID_SRV[$i]} ${proto}"

## unset array (leaves empty item)
        unset PID_SRV[$i]
        unset PID_SRV[$i+1]
        unset PID_SRV[$i+2]
        unset PID_SRV[$i+3]

     fi
    done


### specific:  Proto,  Src port,  Dest port
#   PSD_SRV+=( "<DESC>" "<tcp|udp|both>" "<Source PORT|all>" "<Destination PORT|all>")
    sz_PSD=${#PSD_SRV[@]}
    for (( i=0; i< sz_PSD; i++ ))
    do
      if (( $i % 4 == 0 )); then
        sport="${PSD_SRV[$((i+2))]}"
        if [[ "${sport}" == "all" || "${sport}" == "any" ]]; then
            sport=""
        else
            testNegationPort result ${sport}
            if [ "${result}" == "-0" ]; then
                sport="--sport ${sport}"
            else
                sport="! --sport ${result}"
            fi
            # check for a valid port number
            if [ "${result}" != "-0" ] && [[ !(${result} =~ $PortRangeREGEX) ]]; then
                echo -e "${ReD}Error in PSD_SRV rule${GrN} ${PSD_SRV[$i]} ${ReD}with source port value:${GrN} ${PSD_SRV[$((i+2))]}${DeF}"
            fi
        fi
        dport="${PSD_SRV[$((i+3))]}"
        if [[ "${dport}" == "all" || "${dport}" == "any" ]]; then
            dport=""
        else
            testNegationPort result ${dport}
            if [ "${result}" == "-0" ]; then
                dport="--dport ${dport}"
            else
                dport="! --dport ${result}"
            fi
            # check dport for a valid port number
            if [ "${result}" != "-0" ] && [[ !("${result}" =~ ${PortRangeREGEX}) ]]; then #&& ( "${result}" < 1 || "${result}" > 65535 ) ]]; then
                echo -e "${ReD}Error in PSD_SRV rule${GrN} ${PSD_SRV[$i]} ${ReD}with destination port value:${GrN} ${PSD_SRV[$((i+3))]}${DeF}"
            fi
        fi


        proto="${PSD_SRV[$((i+1))]}"
        if [[ "${proto}" != "any" && "${proto}" != "all" ]]; then
            if [[ "${proto}" == "tcp" ]]; then
                proto="tcp"
            elif [[ "${proto}" == "udp" ]]; then
                proto="udp"
            elif [[ "${proto}" == "both" ]]; then
                $IPTABLES -t filter -A  -m conntrack --ctstate NEW -p tcp      ${sport} ${dport} \
                    -j ACCEPT -m comment --comment "${PSD_SRV[$i]} tcp"
                proto="udp"
            else
                if [[ "${Show_Protocol_Warning}" == "true" ]]; then
                    echo -e "${GrN}Warning in PSD_SRV rule${ReD} ${PSD_SRV[$i]} ${GrN}with protocol value:${ReD} ${PSD_SRV[$((i+1))]}${DeF}"
                    echo -e "${GrN} The firewall does not check for valid protocols, overriding with user input${DeF}"
                fi
            fi
        else
            proto="all"
            if [[ "${sport}" != "" ]]; then
                echo -e "${ReD}Error in PSD_SRV rule${GrN} ${PSD_SRV[$i]} ${ReD}with source port value${GrN} ${PSD_SRV[$((i+2))]}"
                echo -e "${ReD} Unable to assign a port to ${GrN} any ${ReD}or${GrN} all ${ReD}protocols.${DeF}"
            fi
            if [[ "${dport}" != "" ]]; then
                echo -e "${ReD}Error in PSD_SRV rule${GrN} ${PSD_SRV[$i]} ${ReD}with destination port value${GrN} ${PSD_SRV[$((i+3))]}"
                echo -e "${ReD} Unable to assign a port to ${GrN} any ${ReD}or${GrN} all ${ReD}protocols.${DeF}"
            fi
        fi
        $IPTABLES   -t filter -A ${SRV_chain} -m conntrack --ctstate NEW -p ${proto} ${sport} ${dport} \
            -j ACCEPT -m comment --comment "${PSD_SRV[$i]} ${proto}"

## unset array (leaves empty item)
        unset PSD_SRV[$i]
        unset PSD_SRV[$i+1]
        unset PSD_SRV[$i+2]
        unset PSD_SRV[$i+3]

      fi
    done


### specific:  Proto,  src IP,  Src port,  Dest port
#   PISD_SRV+=( "<DESC>" "<tcp|udp|both>" "<src ip|all>" "<src port|all>" "<dest port|all>"
    sz_PISD=${#PISD_SRV[@]}
    for (( i=0; i< sz_PISD; i++ ))
    do
      if (( $i % 5 == 0 )); then
        srcIP="${PISD_SRV[$((i+2))]}"
        if [[ "${srcIP}" == "all" || "${srcIP}" == "any" ]]; then
            srcIP=""
        else
            testNegationIP result ${srcIP}
            if [ "${result}" == "-0" ]; then
                srcIP="-s ${srcIP}"
            else
                srcIP="! -s ${result}"
            fi
            # check for a valid ip/cidr
            if [ "${result}" != "-0" ] && [[ !(${result} =~ $IPCIDRREGEX) ]]; then
                echo -e "${ReD}Error in PISD_SRV rule${GrN} ${PISD_SRV[$i]} ${ReD}with source ip value:${GrN} ${PISD_SRV[$((i+2))]}${DeF}"
            fi
        fi
        sport="${PISD_SRV[$((i+3))]}"
        if [[ "${sport}" == "all" || "${sport}" == "any" ]]; then
            sport=""
        else
            testNegationPort result ${sport}
            if [ "${result}" == "-0" ]; then
                sport="--sport ${sport}"
            else
                sport="! --sport ${result}"
            fi
            # check for a valid port number
            if [ "${result}" != "-0" ] && [[ !(${result} =~ $PortRangeREGEX) ]]; then
                echo -e "${ReD}Error in PISD_SRV rule${GrN} ${PISD_SRV[$i]} ${ReD}with source port value:${GrN} ${PISD_SRV[$((i+3))]}${DeF}"
            fi
        fi
        dport="${PISD_SRV[$((i+4))]}"
        if [[ "${dport}" == "all" || "${dport}" == "any" ]]; then
            dport=""
        else
            testNegationPort result ${dport}
            if [ "${result}" == "-0" ]; then
                dport="--dport ${dport}"
            else
                dport="! --dport ${result}"
            fi
            # check dport for a valid port number
            if [ "${result}" != "-0" ] && [[ !(${result} =~ $PortRangeREGEX) ]]; then 
                echo -e "${ReD}Error in PISD_SRV rule${GrN} ${PISD_SRV[$i]} ${ReD}with destination port value:${GrN} ${PISD_SRV[$((i+4))]}${DeF}"
            fi
        fi

        proto="${PISD_SRV[$((i+1))]}"
        if [[ "${proto}" != "any" && "${proto}" != "all" ]]; then
            if [[ "${proto}" == "tcp" ]]; then
                proto="tcp"
            elif [[ "${proto}" == "udp" ]]; then
                proto="udp"
            elif [[ "${proto}" == "both" ]]; then
                $IPTABLES -t filter -A ${SRV_chain} -m conntrack --ctstate NEW ${srcIP} -p tcp \
                    ${sport} ${dport} -j ACCEPT  -m comment --comment "${PISD_SRV[$i]} tcp"
                proto="udp"
            else
                if [[ "${Show_Protocol_Warning}" == "true" ]]; then
                    echo -e "${GrN}Warning in PISD_SRV rule${ReD} ${PISD_SRV[$i]} ${GrN}with protocol value:${ReD} ${PISD_SRV[$((i+1))]}${DeF}"
                    echo -e "${GrN} The firewall does not check for valid protocols, overriding with user input${DeF}"
                fi
            fi
        else
            proto="all"
            if [[ "${sport}" != "" ]]; then
                echo -e "${ReD}Error in PISD_SRV rule${GrN} ${PISD_SRV[$i]} ${ReD}with source port value${GrN} ${PISD_SRV[$((i+3))]}"
                echo -e "${ReD} Unable to assign a port to ${GrN} any ${ReD}or${GrN} all ${ReD}protocols.${DeF}"
            fi
            if [[ "${dport}" != "" ]]; then
                echo -e "${ReD}Error in PISD_SRV rule${GrN} ${PISD_SRV[$i]} ${ReD}with destination port value${GrN} ${PISD_SRV[$((i+4))]}"
                echo -e "${ReD} Unable to assign a port to ${GrN} any ${ReD}or${GrN} all ${ReD}protocols.${DeF}"
            fi
        fi

        $IPTABLES   -t filter -A ${SRV_chain} -m conntrack --ctstate NEW ${srcIP} -p ${proto} \
            ${sport} ${dport} -j ACCEPT  -m comment --comment "${PISD_SRV[$i]} ${proto}"


## unset array (leaves empty item)
        unset PISD_SRV[$i]
        unset PISD_SRV[$i+1]
        unset PISD_SRV[$i+2]
        unset PISD_SRV[$i+3]
        unset PISD_SRV[$i+4]

      fi
    done
#    shopt -u nocasematch

### end _SRV section



    InsertLayerRule "117"
    # Samba | HTPC
    SMB_chain="INPUT"
    if [[ "$FancyServices" == "true" || "$FancyServices" == "TRUE" ]]; then
        SMB_chain="Services"
        #$IPTABLES -N $SMB_chain
        $IPTABLES -A INPUT -j ${SMB_chain}     -m comment --comment "Samba Services"
    fi

    for (( i=0; i< ${#SAMBA[@]}; i++ ))
    do
      $IPTABLES -A ${SMB_chain} -p udp -m udp -s ${SAMBA[$i]} --dport 137 -j ACCEPT   -m comment --comment "SAMBA $((i+1))"
      $IPTABLES -A ${SMB_chain} -p udp -m udp -s ${SAMBA[$i]} --dport 138 -j ACCEPT   -m comment --comment "SAMBA $((i+1))"
      $IPTABLES -A ${SMB_chain} -m conntrack --ctstate NEW -m tcp -p tcp -s ${SAMBA[$i]} --dport 139 -j ACCEPT   -m comment --comment "SAMBA $((i+1))"
      $IPTABLES -A ${SMB_chain} -m conntrack --ctstate NEW -m tcp -p tcp -s ${SAMBA[$i]} --dport 445 -j ACCEPT   -m comment --comment "SAMBA $((i+1))"
    done
        # All IPs
    #     $IPTABLES -A INPUT -p udp -m udp --dport 137 -j ACCEPT
    #     $IPTABLES -A INPUT -p udp -m udp --dport 138 -j ACCEPT
    #     $IPTABLES -A INPUT -m conntrack --ctstate NEW -m tcp -p tcp --dport 139 -j ACCEPT
    #     $IPTABLES -A INPUT -m conntrack --ctstate NEW -m tcp -p tcp --dport 445 -j ACCEPT



    InsertLayerRule "118"
    # mDNS / IPP + other 224/225 broadcast services





    # Max. 500/Seconds (5/Jiffie) send
#    echo 5 > /proc/sys/net/ipv4/icmp_ratelimit

    # Memory Allocation and -Timing for IP-De/-Fragmenting
#    echo 262144 > /proc/sys/net/ipv4/ipfrag_high_thresh
#    echo 196608 > /proc/sys/net/ipv4/ipfrag_low_thresh
#    echo 30 > /proc/sys/net/ipv4/ipfrag_time

    # TCP-FIN-Timeout to Protection for DoS-Attack
#    echo 30 > /proc/sys/net/ipv4/tcp_fin_timeout

   # Maximal 3 Answers on TCP-SYN
#    echo 3 > /proc/sys/net/ipv4/tcp_retries1

    # TCP-Packet maximally 15x repeat
#    echo 15 > /proc/sys/net/ipv4/tcp_retries2


    $IPTABLES -t filter -D INPUT 1

# Dynamic Hosts INPUT CHAIN
    $IPTABLES -I INPUT 1 -j dtfwdynamichosts

# Dynamic Hosts Flush chain
    $IPTABLES -F dtfwdynamichosts

    BLchain="INPUT"
    if [[ "$FancyListsIN" == "true" || "$FancyListsIN" == "TRUE" ]]; then
        BLchain="BlackListIN"
        $IPTABLES -N $BLchain
        $IPTABLES -I INPUT 1 -j ${BLchain}     -m comment --comment "BlackList Chain"
    fi

   ### Blacklist
   #
   if [ ! -r "$BLACKLIST" ]; then
     echo -e "${ReD}cannot read Blacklist at \"${BLACKLIST}\"!${DeF}"
   else
## old method
#       bl=1
#       whiteSpace="         "
#     for x in `grep -v ^# $BLACKLIST | awk '{print $1}'`; do
#       if [ "$bl" == "1" ]; then  echo " Denying Blacklisted IPs:"; fi
#       echo "    $bl: $x"
#       $IPTABLES -I INPUT ${bl} -t filter -s $x -j DROP   -m comment --comment "blacklist ${bl}"
#       bl=$((bl+1));
#     done
       bl=1
       whiteSpace="         "
       grep -v "^#" $BLACKLIST | grep -v "^$" | while read a; do
           if [ "$bl" == "1" ]; then  echo " Denying Blacklisted IPs:"; fi
           sz=${#a}
           bip=`echo $a | awk '{print $1}'`
           szip=${#bip}
           comment=`echo ${a:szip} | sed 's/ *$//g'`
           ws=${whiteSpace:0:20-szip}
           echo "    $bl: ${bip}${ws}$comment"
           ##printf "    %s: ${bip}${ws}$comment"
           $IPTABLES -I ${BLchain} ${bl} -t filter -s $bip -j DROP   -m comment --comment "Blacklist ${bl} ${comment}"
           bl=$((bl+1));
        done
   fi
   InsertLayerRule "104" # input  blacklist
   InsertLayerRule "163" # output blacklist



   ### SSH Guard
   #
   if [[ "${UseSSHGuard}" == "true" ]]; then
     $IPTABLES -N ${SSHG_TableName}
     $IPTABLES -I INPUT 1 ${sshguard_params} ${sshguard_moreps} -j ${SSHG_TableName}   -m comment --comment "sshguard"
     echo -e -n " SSHGuard initiated, executing: "
     echo -e "${GrN}iptables -I INPUT 1 ${sshguard_params} ${sshguard_moreps} -j ${SSHG_TableName} -m comment --comment \"sshguard\"${DeF}"
   fi
   InsertLayerRule "103" # sshguard (input)


    WLchain="INPUT"
    if [[ "$FancyListsIN" == "true" ]]; then
        WLchain="WhiteListIN"
        $IPTABLES -N $WLchain
        $IPTABLES -I INPUT 1 -j ${WLchain} -m comment --comment "WhiteList Chain"
    fi

   ### Whitelist
   #
### find . -type f | grep -s ".*\.sh$" | while read a; do chmod +x "$a"; done
   if [ ! -r "$WHITELIST" ]; then
     echo -e "${ReD}cannot read Whitelist at \"${WHITELIST}\", allowing ALL traffic!${DeF}"
     $IPTABLES -I INPUT 1 -j ACCEPT     -m comment --comment "whitelist error, allowing all"
     $IPTABLES -I FORWARD 1 -j ACCEPT   -m comment --comment "whitelist error, allowing all"
     $IPTABLES -I OUTPUT 1 -j ACCEPT    -m comment --comment "whitelist error, allowing all"
   else
## old method
#     wl=1;
#     for x in `grep -v ^# $WHITELIST | awk '{print $1}'`; do
#       if [ "$wl" == "1" ]; then  echo " Permitting Whitelisted IPs:"; fi
#       echo "    $wl: $x"
#       $IPTABLES -I INPUT ${wl} -t filter -s $x -j ACCEPT   -m comment --comment "whitelist ${wl}"
## IF          $IPTABLES -I OUTPUT ${wl} -t filter -s $x -j ACCEPT   -m comment --comment "whitelist ${wl}"
#       wl=$((wl+1));
#     done
       wl=1;
       whiteSpace="         "
       grep -v "^#" $WHITELIST | grep -v "^$" | while read a; do
           if [ "$wl" == "1" ]; then  echo " Permitting Whitelisted IPs:"; fi
           sz=${#a}
           wip=`echo $a | awk '{print $1}'`
           szip=${#wip}
           comment=`echo ${a:szip} | sed 's/ *$//g'`
           ws=${whiteSpace:0:20-szip}
           echo "    $wl: ${wip}${ws}$comment"
           $IPTABLES -I ${WLchain} ${wl} -t filter -s $wip -j ACCEPT   -m comment --comment "whitelist ${wl} ${comment}"
           wl=$((wl+1));
       done

   fi
   InsertLayerRule "102" # input  whitelist
   InsertLayerRule "162" # output whitelist


   # Torrent DHT lines to aid in tracking to help keep ratio's updated.
   # $IPTABLES -t raw -I PREROUTING -p udp --dport $TORRENTPORT -j NOTRACK
   # $IPTABLES -t raw -I OUTPUT -p udp --sport $TORRENTPORT -j NOTRACK

   # Log All Packets (inserted as first rule)
   if [[ "$LOG_ALL_PACKETS" == "true" || "$LOG_ALL_PACKETS" == "1" || "$LOG_ALL_PACKETS" == "yes" ]]; then
       echo -e " Logging All Packets."
       $IPTABLES -I INPUT 1 -j LOG --log-prefix "${LogPrefix}Log All INPUT "     -m comment --comment "Log All INPUT"
       $IPTABLES -I OUTPUT 1 -j LOG --log-prefix "${LogPrefix}Log All OUTPUT "   -m comment --comment "Log All OUTPUT"
       $IPTABLES -I FORWARD 1 -j LOG --log-prefix "${LogPrefix}Log All FORWARD " -m comment --comment "Log All FORWARD"
   fi

   InsertLayerRule "101" # input   - LogAllPackets
   InsertLayerRule "119" # log bogus inbound connections (last rule)
   InsertLayerRule "131" # forward - LogAllPackets
   InsertLayerRule "161" # output  - LogAllPackets


    # Log Bogus and Last Line segment
    ###
    ## INPUT_LOG_BOGUS
    if [[ "$INPUT_LOG_BOGUS" == "true" ]]; then
      echo " Logging bogus/leftover inbound traffic."
      $IPTABLES -A INPUT -j LOG --log-prefix "${LogPrefix}log bogus inbound "   -m comment --comment "log bogus inbound connections"
    fi
    ## INPUT_LAST_LINE
    if [[ "$INPUT_LAST_LINE" == "REJECT" ]]; then
      $IPTABLES -A INPUT -p tcp -j REJECT --reject-with tcp-reset               -m comment --comment "send tcp reset"
      #$IPTABLES -A INPUT -p udp -j DROP                             -m comment --comment "drop udp"
      $IPTABLES -A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable   -m comment --comment "send port unreachable udp"
    fi

    ## FORWARD_LOG_BOGUS
    if [[ "$FORWARD_LOG_BOGUS" == "true" ]]; then
      echo " Logging bogus/leftover forward traffic."
      $IPTABLES -A FORWARD -j LOG --log-prefix "${LogPrefix}log bogus forward "   -m comment --comment "log bogus forward connections"
    fi
    ## FORWARD_LAST_LINE
    if [[ "$FORWARD_LAST_LINE" == "REJECT" ]]; then
      $IPTABLES -A FORWARD -p tcp -j REJECT --reject-with tcp-reset               -m comment --comment "send tcp reset"
      #$IPTABLES -A FORWARD -p udp -j DROP                             -m comment --comment "drop udp"
      $IPTABLES -A FORWARD -p udp -j REJECT --reject-with icmp-port-unreachable   -m comment --comment "send port unreachable udp"
    fi

    ## OUTPUT_LOG_BOGUS
    if [[ "$OUTPUT_LOG_BOGUS" == "true" ]]; then
      echo " Logging bogus/leftover outbound traffic."
      $IPTABLES -A OUTPUT -j LOG --log-prefix "${LogPrefix}log bogus outbound "   -m comment --comment "log bogus outbound connections"
    fi
    ## OUTPUT_LAST_LINE
    if [[ "$OUTPUT_LAST_LINE" == "REJECT" ]]; then
      $IPTABLES -A OUTPUT -p tcp -j REJECT --reject-with tcp-reset               -m comment --comment "send tcp reset"
      #$IPTABLES -A OUTPUT -p udp -j DROP                             -m comment --comment "drop udp"
      $IPTABLES -A OUTPUT -p udp -j REJECT --reject-with icmp-port-unreachable   -m comment --comment "send port unreachable udp"
    fi
    ###
    # end Log Bogus and Last Line segment

    # DTfw Dynamic Host
    if [ -f $DYNHOSTSCRIPT ];then
       echo " Converting Host names to IPs"
       sh $DYNHOSTSCRIPT
    else
      echo " DTfw Dynamic Hosts script not in use."
    fi


    WLchain="INPUT"
    if [[ "$FancyListsIN" == "true" ]]; then
        WLchain="DynDnsWhiteListIN"
        $IPTABLES -N $WLchain
        $IPTABLES -I INPUT 1 -j ${WLchain} -m comment --comment "DynDnsWhiteList Chain"
    fi

   ### DynDnsWhitelist
   #
   ### find . -type f | grep -s ".*\.sh$" | while read a; do chmod +x "$a"; done
   if [ ! -r "$DYNDNSWHITELIST" ]; then
     echo -e "${ReD}cannot read Whitelist at \"${DYNDNSWHITELIST}\", allowing ALL traffic!${DeF}"
     $IPTABLES -I INPUT 1 -j ACCEPT -m comment --comment "dyndns whitelist error, allowing all"
     $IPTABLES -I FORWARD 1 -j ACCEPT -m comment --comment "dyndns whitelist error, allowing all"
     $IPTABLES -I OUTPUT 1 -j ACCEPT -m comment --comment "dyndns whitelist error, allowing all"
   else
       wl=1;
       whiteSpace="         "
       grep -v "^#" $DYNDNSWHITELIST | grep -v "^$" | while read a; do
           if [ "$wl" == "1" ]; then  echo " Permitting DynDns Whitelisted IPs:"; fi
           sz=${#a}
           wip=`echo $a | awk '{print $1}'`
           szip=${#wip}
           comment=`echo ${a:szip} | sed 's/ *$//g'`
           ws=${whiteSpace:0:20-szip}
           echo "    $wl: ${wip}${ws}$comment"
           $IPTABLES -I ${WLchain} ${wl} -t filter -s $wip -j ACCEPT -m comment --comment "dyndns whitelist ${wl} ${comment}"
           wl=$((wl+1));
       done

   fi
   InsertLayerRule "100" # input  whitelist
   InsertLayerRule "160" # output whitelist


   # Default-Policies
   $IPTABLES -P INPUT DROP
   $IPTABLES -P OUTPUT DROP
   $IPTABLES -P FORWARD DROP




   echo " Firewall Started"

   shopt -u nocasematch
    ;;

  stop)
    echo
    echo " - DTfw Script Stopped - "
    echo
    # Table Flush
    $IPTABLES -t filter -F
    $IPTABLES -t nat -F
    $IPTABLES -t mangle -F
    $IPTABLES -X
    $IPTABLES -t nat -X
    $IPTABLES -t mangle -X
    # Default-Policies set
    $IPTABLES -P INPUT ACCEPT
    $IPTABLES -P OUTPUT ACCEPT
    $IPTABLES -P FORWARD ACCEPT
    ;;

  restart)
    echo
    echo -e " - DTfw $VER - "
    echo
    echo " Restarting Firewall"
    sleep 2
    echo " Flushing Firewall..."
    sleep 1
    echo " Starting Firewall..."
    $SCRIPT start
    sleep 1
    echo " Saving New Settings..."
    echo " Firewall On..."
    echo " "
      ;;

  save)
    echo
    echo -e " - DTfw $VER - "
    echo
    echo " Saving Tables"
    $IPTABLESSAVE > $FWSAVE
    echo " IPTable Rules Saved"
    ;;

  restore)
    echo
    echo -e " - DTfw $VER - "
    echo
    echo " Restoring IPTables Rules"
    $IPTABLESRESTORE < $FWSAVE
    echo " IPTable Rules Restored"
    ;;

  status)
    echo
    echo -e " - DTfw $VER - "
    echo
    echo " Table Filter"
    $IPTABLES -L -vn
    echo " Table Nat"
    $IPTABLES -t nat -L -vn
    echo " Table Mangle"
    $IPTABLES -t mangle -L -vn
    ;;

  *)
    echo
    echo -e " - DTfw $VER - "
    echo
    echo -e " ${ReD}Incorrect Call${DeF}"
    echo " Syntax: $0 {start|stop|restart|save|restore|status}"
    exit 1
    ;;

esac

