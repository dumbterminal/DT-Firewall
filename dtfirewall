#!/bin/bash
#
# Dumb Terminal IPTables Firewall Script
#  script to aid the use of IPTables - http://www.netfilter.org/projects/iptables/index.html 
#   more aid from: http://pikt.org/pikt/samples/iptables_tcp_flags_programs.cfg.html
#                  http://pettingers.org/code/firewall.html
#                  http://www.newartisans.com/2007/09/neat-tricks-with-iptables.html
# This script does not make extra tables for the eye candy of the user.
#  In theory it will run faster because the lack of table processing.
#
# http://dt.tehspork.com
# Dumb Terminal
#  Smaller than Life Projects
# Main Page: http://dt.tehspork.com
# Git Repo: https://github.com/dumbterminal/
# By: MikereDD & veekahn
# email: dumbterminal -at- tehspork.com
## 
# Much Thanx to Veekahn
#  for helping with specific IP lines. :)
#
## Last Update
## Tue Mar 07 00:21:13 PST 2011
#  2011-03-07
#
## 'TODO' (among the objects listed in the "iptables output order"
#  kernel firewall WARNING logging (log level 4 -default)
#  SCRIPT=  (change it to dt.firewall ?)
#  SPOOF_IPS (on WAN only), WAN vs LAN auto detection per iface - reseach -s and -d spoofed ips 
#  LogAllValidPackets - input, forward, output
#   allow "BOTH" option for Proto in InsertLayerRule
#   implement the ! (not) condition for InsertLayerRule
#   implement iface parameter for InsertLayerRule
VER="1.7beta2" 


# iptables output order/levels
# INPUT: InsertLayerRule 
# 1  1 LogAllPackets_INPUT (optional) 
# 1  2 whitelist 
# 1  3 sshguard 
# 1  4 blacklist 
# A  5 block spoofing (for WAN use only!) [TODO: auto-detection] 
# A  6 connection tracking: ESTABLISHED,RELATED 
# A  7 allow localhost 
# A  8 allow lo iface 
# A  9 drop corrupt packets 
# A 10 bad packets/scans 
# A 11 force fragment packet check
# A 12 special port 111, 113, 520 cases 
# A 13 icmp ping allow/deny/limit 
# A 14 other flood protections - FORWARDing limits - TODO
# A 15 block brute force 
# A 16 good-packet ACCEPT - allows: 
#      - General Services (specific destination port) 
#      - Specific Port Services (source and destination) 
#      - Specific Source IP:Port, Dest Port 
#      - Specific Source IP, Dest Port 
# A 17 samba [enabled for spceified ip/subnet] 
# A 18 reject/drop logging (last rule) 
# FORWARD: 
# 1 19 LogAllPackets_FORWARD (optional) 
# A 20 connection tracking: ESTABLISHED,RELATED 
# A 21 force ACCEPT rules [TODO] 
# A 22 drop corrupt packets 
# A 23 bad packets/scans  # [ do these need to exist ?? ]
# A 24 force fragment packet check
# A 25 Flood Protection - limit DoS
# A 26 good-packet ACCEPT rules [TODO] - destinations! 
# A 27 if not ppp0 then allow: NEW,ESTABLISHED,RELATED 
# A 28 reject/drop logging (last rule) 
# OUTPUT: 
# 1 29 LogAllPackets_OUTPUT (optional) 
# 1 30 WHITELIST ( load INPUT whitelist, load second file, load array ) not_TODO 
# 1 31 BLACKLIST ( load second file, load array ) TODO (optional) 
# A 32 connection tracking: ESTABLISHED,RELATED [disabled on force outbound corrupt packet check] 
# A 33 accept lo iface OUTPUT
# A 34 drop corrupt packets 
# A 35 DROP/REJECT rules [TODO] - destination port blocking (source IP blocking) - iface? 
# A 36 new+connection tracking: NEW,ESTABLISHED,RELATED 
# A 37 reject/drop logging (last rule) 


## list initializations, don't remove! 
  SAMBA=( )
  SPOOF_IPS=( )
  Block_Ping=( )
  sshguard_params=( )
  sshguard_moreps=( )
  OTHER_FLOODS=( )
  BruteForce=( )
  IFACES=( ) #not used yet 
  PD_SRV=( )    # Proto,  Dest port 
  PID_SRV=( )   # Proto,  src IP,  Dest port 
  PSD_SRV=( )   # Proto,  Src port,  Dest port 
  PISD_SRV=( )  # Proto,  src IP,  Src port,  Dest port 
  LayerRule=( ) 
  # some colors
  ReD='\033[0;31m'
  GrN='\033[0;32m'
  DeF='\033[0m'
## end initializations 


# Path to Script  - used for  `restart` 
SCRIPT=/etc/rc.d/dfirewall

# Server is behind a router or directly connected to the internet 
### not fully implemented 
# IFACE="LAN" 
# IFACE="WAN" 
# IFACE+=("eth0" "LAN") 
# IFACE+=("eth1" "WAN") 


## Specify where IP Tables is located 
# not necessary for: 
#   archlinux, debian, redhat, centos 
IPTABLES=''


# Path to iptables-save 
IPTABLESSAVE=/usr/sbin/iptables-save

# Path to iptables-restore 
IPTABLESRESTORE=/usr/sbin/iptables-restore

# Path to IPTables Rules 
FWSAVE=/etc/iptables/iptables.rules

# Location of ModProbe 
MODPROBE=/sbin/modprobe



#
## List Locations
#
WHITELIST=/usr/local/etc/dtfw_whitelist.txt
BLACKLIST=/usr/local/etc/dtfw_blacklist.txt
#OUT_WHITELIST=/usr/local/etc/whitelist.txt   # most likely not implemented
OUT_BLACKLIST=/usr/local/etc/dtfw_blacklist_OUTS.txt   # not implemented - optional


# true/false
##
# enable logging in general
EnableLog="true"
# log prefix for logged segments' prefixes
LogPrefix="dtFW: "
##
LOG_ALL_PACKETS="true"
##
# Check Outbound traffic and restrict sending corrupt data
#Block_Corrupt_Outbound="true"
Block_Corrupt_Outbound="false"
##
# icmp ping allow/deny/limit: Block Ping 
# "false | no",  "drop",  "reject" "<mode>",  "limit" "<RATE>" "<burst>" 
  ## RATE =  <packets> / <s|second> | <m|minute> | <h|hour> | <d|day> 
  ## REJECT Modes: 
  ## 1: icmp-port-unreachable 
  ## 2: icmp-net-unreachable 
  ## 3: icmp-host-unreachable 
  ## 4: icmp-proto-unreachable 
  ## 5: icmp-net-prohibited 
  ## 6: icmp-host-prohibited 
#Block_Ping=("false")
Block_Ping=("no")
#Block_Ping=("DROP")
#Block_Ping=("reject" "3")
#Block_Ping=("limit" "1/s" "5") 
##
# end true/false



# Other flood protections [limit rate in FORWARD] - prevent DoS 
#   http://netfilter.org/documentation/HOWTO/packet-filtering-HOWTO-7.html
# <rate>/ <s|second> | <m|minute> | <h|hour> | <d|day>
OTHER_FLOODS+=("syn flood" "1/s")
OTHER_FLOODS+=("furtive port scanner" "1/s")
OTHER_FLOODS+=("ping of death" "1/s")


## sshguard
UseSSHGuard="true"
SSHG_TableName="sshguard"
# Specify parameters for SSH guard, and any additional IPTABLES syntaxed parameters
sshguard_params="-p tcp --dport 22"
sshguard_moreps="! -s 130.157.33.0/24"



# Allow Samba/HTPC on specific ip/subnet
#SAMBA+=("ip" "ip/cidr")
SAMBA+=("192.168.1.0/24")


# Block Brute Force Ports + Names
#BruteForce+=("port:(s)" "description")
BruteForce+=("21:22" "FTP:SSH")
BruteForce+=("41331" "webmin")




### General Services (specific destination port)
##  PD_SRV+=( "<DESC>" "<tcp|udp|both>" "<PORT>" )
PD_SRV+=("HTTP" "tcp" "8080")
#PD_SRV+=("HTTPS" "tcp" "443")
PD_SRV+=("SSH" "tcp" "443")
PD_SRV+=("SMPT" "tcp" "25")
PD_SRV+=("SMPTS" "tcp" "465")
PD_SRV+=("IRC" "both" "6667:6669")
PD_SRV+=("torrent" "tcp" "57070:57076")
PD_SRV+=("KDX" "tcp" "666")


### Specific Source IP, Dest Port
##  PID_SRV+=( "<DESC>" "<tcp|udp|both>" "<src ip>" "<dst port | all>"
PID_SRV+=("http configs" "tcp" "192.168.1.0/24" "8079")
PID_SRV+=("http configs" "tcp" "192.168.3.0/24" "8079")
PID_SRV+=("http configs" "tcp" "172.16.88.0/24" "8079")
PID_SRV+=("ssh gamebox" "tcp" "192.168.1.6/32" "22")
PID_SRV+=( "SSH vmNat" "tcp" "172.16.88.0/24" "22" )
PID_SRV+=("http configs mbp" "tcp" "172.16.88.0/24" "8079")
PID_SRV+=("synergy" "tcp" "192.168.1.6/32" "24800")
PID_SRV+=("synergy" "tcp" "192.168.1.41/32" "24800")
PID_SRV+=("gamebox" "both" "192.168.1.6/32" "all")
PID_SRV+=( "ssh scwa" "tcp" "75.26.142.246/32" "22" )
PID_SRV+=( "ssh scwa" "tcp" "75.26.142.246/32" "443" )


### Specific Port Services (source and destination)
##  PSD_SRV+=( "<DESC>" "<tcp|udp|both>" "<Source PORT>" "<Destination PORT>")
PSD_SRV+=( "TELNET bot1" "tcp" "31840:31848" "1843" )
#PSD_SRV+=( "TELNET bot2" "tcp" "31840:31848" "1844" )
#PSD_SRV+=( "TELNET bot3" "tcp" "31840:31848" "1845" )
#PSD_SRV+=( "TELNET bot4" "tcp" "31840:31848" "1846" )


### Specific Source IP:Port, Dest Port
##  PISD_SRV+=( "<DESC>" "<tcp|udp|both>" "<src ip>" "<src port>" "<dest port>"
#PISD_SRV+=( "TELNET bot5" "tcp" "127.0.0.1" "31840:31848" "1843" )
#PISD_SRV+=( "TELNET bot6" "tcp" "127.0.0.1" "31840:31848" "1844" )
#PISD_SRV+=( "TELNET bot7" "tcp" "127.0.0.1" "31840:31848" "1845" )
PISD_SRV+=( "TELNET bot8" "tcp" "127.0.0.1" "31840:31848" "1846" )
PISD_SRV+=( "Bnc" "tcp" "174.122.218.237" "52010:52021" "366" )


# Specific:  Proto,  Source IP:Port,  Dest IP:Port,  Action
# LayerRule=+( "<layer> "<DESC>" "<tcp|udp>" "<src ip>" "<src port>" "<dest ip>" "<dest port>" "<Action>" 
  ##  Action Modes: 
    ##  ACCEPT 
    ##  DROP 
    ##  Reject <mode> 
    ##  Limit <rate> <burst> 
    ##  LOG <log prefix text>
  ## Reject Modes: 
    ## 1: icmp-port-unreachable       ## 2: icmp-net-unreachable   
    ## 3: icmp-host-unreachable       ## 4: icmp-proto-unreachable 
    ## 5: icmp-net-prohibited         ## 6: icmp-host-prohibited   
    ## 7: tcp-reset 
  ## Limit Modes: 
    ## rate:   <packets>/ <s|second> | <m|minute> | <h|hour> | <d|day> 
    ## burst:  # packet burst 

LayerRule+=( "37" "testah" "TCP" "" "8080" "" "81" "reject 3" )
LayerRule+=( "37" "testah" "TCP" "" "8080" "" "81" "drop" )
LayerRule+=( "37" "testah" "TCP" "" "8080" "" "81" "limit 1024/h 4" )
LayerRule+=( "37" "testah" "TCP" "" "8080" "" "81" "log log prefix text" )
##LayerRule+=( "36" "testah" "TCP" "" "8080" "" "81" "limit 8/s 5" )


#INPUT
LayerRule+=( "1" "t 1" "" "" "" "" "" "" )
LayerRule+=( "2" "t 2" "" "" "" "" "" "" )
LayerRule+=( "3" "t 3" "" "" "" "" "" "" )
LayerRule+=( "4" "t 4" "" "" "" "" "" "" )
LayerRule+=( "5" "t 5" "" "" "" "" "" "" )
LayerRule+=( "6" "t 6" "" "" "" "" "" "" )
LayerRule+=( "7" "t 7" "" "" "" "" "" "" )
LayerRule+=( "8" "t 8" "" "" "" "" "" "" )
LayerRule+=( "9" "t 9" "" "" "" "" "" "" )
LayerRule+=( "10" "t 10" "" "" "" "" "" "" )
LayerRule+=( "11" "t 11" "" "" "" "" "" "" )
LayerRule+=( "12" "t 12" "" "" "" "" "" "" )
LayerRule+=( "13" "t 13" "" "" "" "" "" "" )
LayerRule+=( "14" "t 14" "" "" "" "" "" "" )
LayerRule+=( "15" "t 15" "" "" "" "" "" "" )
LayerRule+=( "16" "t 16" "" "" "" "" "" "" )
LayerRule+=( "17" "t 17" "" "" "" "" "" "" )
#FORWARD
LayerRule+=( "18" "t 18" "" "" "" "" "" "" )
LayerRule+=( "19" "t 19" "" "" "" "" "" "" )
LayerRule+=( "20" "t 20" "" "" "" "" "" "" )
LayerRule+=( "21" "t 21" "" "" "" "" "" "" )
LayerRule+=( "22" "t 22" "" "" "" "" "" "" )
LayerRule+=( "23" "t 23" "" "" "" "" "" "" )
LayerRule+=( "24" "t 24" "" "" "" "" "" "" )
LayerRule+=( "25" "t 25" "" "" "" "" "" "" )
LayerRule+=( "26" "t 26" "" "" "" "" "" "" )
LayerRule+=( "27" "t 27" "" "" "" "" "" "" )
LayerRule+=( "28" "t 28" "" "" "" "" "" "" )
#OUTPUT
LayerRule+=( "29" "t 29" "" "" "" "" "" "" )
LayerRule+=( "30" "t 30" "" "" "" "" "" "" )
LayerRule+=( "31" "t 31" "" "" "" "" "" "" )
LayerRule+=( "32" "t 32" "" "" "" "" "" "" )
LayerRule+=( "33" "t 33" "" "" "" "" "" "" )
LayerRule+=( "34" "t 34" "" "" "" "" "" "" )
LayerRule+=( "35" "t 35" "" "" "" "" "" "" )
LayerRule+=( "36" "t 36" "" "" "" "" "" "" )
LayerRule+=( "37" "t 37" "" "" "" "" "" "" )
LayerRule+=( "38" "t 38" "" "" "" "" "" "" )
LayerRule+=( "39" "t 39" "" "" "" "" "" "" )



# IP Subnets to block from spoofing
# blocks listed addresses from INPUT on all but iface lo
# remember WHITELIST contains ip/range of all allowed subnets
#if [ "${IFACE}" -eq "WAN" ]; then
SPOOF_IPS+=("0.0.0.0/8")
SPOOF_IPS+=("127.0.0.0/8")
SPOOF_IPS+=("10.0.0.0/8")
SPOOF_IPS+=("172.16.0.0/12")
SPOOF_IPS+=("192.168.0.0/16")
SPOOF_IPS+=("224.0.0.0/3")
## http://www.newartisans.com/2007/09/neat-tricks-with-iptables.html
#   Scapy - check attacks with
##   source and destination IPs specified 
#elif [ "${IFACE}" -eq "LAN" ]; then


## Malformed/Bad Packet drop
# 
DropTableName="MY_DROP"
LOG_Droped="true"

### log all remaining traffic 
INPUT_LOG_BOGUS="true"
FORWARD_LOG_BOGUS="true"
OUTPUT_LOG_BOGUS="true"
### last line should REJECT with TCP Reset, or DROP 
#  = "DROP" or "REJECT" 
INPUT_LAST_LINE="REJECT"   # TODO: make variable a better name 
FORWARD_LAST_LINE="REJECT"
OUTPUT_LAST_LINE="REJECT"

## Bandwidth Rates
# BW_Rates="<off | packet/rate>"
BW_Rates="1700/h"
# hard-coded "off"









#### stay the hell out of the area below this line ####
#######################################################

# if iptables location is not set, find common location
if [ ! -x "${IPTABLES}" ]; then
  # debian+redhat+centos
  if [   -x /sbin/iptables     ]; then   IPTABLES=/sbin/iptables
  # archlinux
  elif [ -x /usr/sbin/iptables ]; then   IPTABLES=/usr/sbin/iptables
  else
      LOCATEIPT=`whereis iptables | awk '{print $2}'`
      if [ -x "${LOCATEIPT}" ]; then
          IPTABLES=${LOCATE}
      else
          echo -e "${ReD}error locating iptables, please specify location or correct execution permissions${DeF}"
          exit
      fi
  fi
fi


### Level function; for insertion of allows/deny's at a specific level
#   uses the variable LayerRule=+( "<layer> "<DESC>" "<tcp|udp|both>" "<src ip>" "<src port>" "<dest ip>" "<dest port>" "<accept/drop/reject/limit>" )
#    leave an item blank, "", to skip the parameter (if no protocol, then no src/dest port can be used!)
##  an advanceed PISD_SRV modification (Protocol, source IP, Source port, Destination port
#  
#    Specific:  Proto,  Source IP:Port,  Dest IP:Port
#    "<layer>" "<DESC>" "<tcp|udp>" "<src ip>" "<src port>" "<dest ip>" "<dest port>" "<accept | drop |
#                                                                                             reject <method #>
#                                                                                             limit  <rate> <burst>
#                                                                                             log <log-text>
#
##  if "<layer>" is equal to $1, then insert rule before 
function InsertLayerRule {
    for (( i=0; i< ${#LayerRule[@]}; i++ ))
    do
        if (( $i % 8 == 0 )); then
        if [ "${1}" == "${LayerRule[$((i+0))]}" ]; then
            layer=${LayerRule[$((i+0))]}
            desc="${LayerRule[$((i+1))]}"
            
            Proto="";  srcIP=""; SrcP="";
            DestIP=""; DestP=""; action="";
            
            if [ -n "${LayerRule[$((i+2))]}" ]; then
                Proto="-p ${LayerRule[$((i+2))]}"
            fi
            if [ -n "${LayerRule[$((i+3))]}" ]; then
                srcIP="-s ${LayerRule[$((i+3))]}"
            fi
            if [ -n "${LayerRule[$((i+4))]}" ]; then
                SrcP="--sport ${LayerRule[$((i+4))]}"
            fi
            if [ -n "${LayerRule[$((i+5))]}" ]; then
                DestIP="-d ${LayerRule[$((i+5))]}"
            fi
            if [ -n "${LayerRule[$((i+6))]}" ]; then
                DestP="--dport ${LayerRule[$((i+6))]}"
            fi
            ##  ACTION  area
            action="${LayerRule[$((i+7))]}"
            prefix=''
            #${LayerRule[$((i+7))]}   
            if [ "$action" == "drop" -o "$action" == "DROP" ]; then
                action="-j DROP"
            elif [ "$action" == "accept" -o "$action" == "ACCEPT" ]; then
                action="-j ACCEPT"
            else
                # REJECT or LIMIT
                action=`echo "${LayerRule[$((i+7))]}" | awk '{print $1}'`
                p1=`echo "${LayerRule[$((i+7))]}" | awk '{print $2}'`
                ##
                # REJECT
                if [ "$action" == "reject" -o "$action" == "REJECT" ]; then
                    sendBack="--reject-with"
                    case "${p1}" in
                        1|icmp-port-unreachable)
                            sendBack="${sendBack} icmp-port-unreachable"  ;;
                        2|icmp-net-unreachable)
                            sendBack="${sendBack} icmp-net-unreachable"   ;;
                        3|icmp-host-unreachable)
                            sendBack="${sendBack} icmp-host-unreachable"  ;;
                        4|icmp-proto-unreachable)
                            sendBack="${sendBack} icmp-proto-unreachable" ;;
                        5|icmp-net-prohibited)
                            sendBack="${sendBack} icmp-net-prohibited"    ;;
                        6|icmp-host-prohibited)
                            sendBack="${sendBack} icmp-host-prohibited"   ;;
                        7|tcp-reset)
                            sendBack="${sendBack} tcp-reset"              ;;
                        *)
                            echo -e -n "${ReD}Error in Reject Method '${GrN}${p1}${ReD}' in LayerRule: "
                            echo -n -e "  Layer:  "
                            echo -n -e            "${LayerRule[$((i+0))]},  Proto: '${LayerRule[$((i+2))]}',  "
                            echo -n -e            "src ip: '${LayerRule[$((i+3))]}',  src port: '${LayerRule[$((i+4))]}',  "
                            echo -n -e            "dest ip: '${LayerRule[$((i+5))]}',  dest port: '${LayerRule[$((i+6))]}',  action: '${LayerRule[$((i+7))]}',  "
                            echo    -e            "reject method: '${p1}'."
                            if [ "${LayerRule[$((i+2))]}" == "TCP" -o "${LayerRule[$((i+2))]}" == "tcp" ]; then
                                echo -e "${GrN}Using method #7: tcp-reset.${DeF}"
                                sendBack="${sendBack} tcp-reset"
                            #elif [ "${LayerRule[$((i+2))]}" == "UDP" -o "${LayerRule[$((i+2))]}" == "udp" ]; then
                            else
                                echo -e "${GrN}Using method #1: icmp-port-unreachable.${DeF}"
                                sendBack="${sendBack} icmp-port-unreachable"
                            #else
                            #    echo -e "${GrN}Using method #8: echo-reply.${DeF}"
                            #    sendBack="${sendBack} "
                            fi
                    esac
                    action="-j REJECT ${sendBack}"
                # end REJECT
                ##
                # LIMIT
                elif [ "$action" == "limit" -o "$action" == "LIMIT" ]; then
                    p2=`echo "${LayerRule[$((i+7))]}" | awk '{print $3}'`
                    if  echo $p2 | grep "^[0-9]*$">aux ; then
                        if (( p2 > 0 )); then
                            action="-m limit --limit ${p1} --limit-burst ${p2} -j ACCEPT"
                        else
                            echo -e "${ReD}Error with LayerRule: $p2 is not a valid burst rate.${DeF}"
                            echo -e "${GrN}Applying rule without Burst Rate option.${DeF}"
                            action="-m limit --limit ${p1}  -j ACCEPT"
                        fi
                    else
                        echo -e "${ReD}Error with LayerRule: $p2 is not a valid burst rate.${DeF}"
                        echo -e "${GrN}Applying rule without Burst Rate option.${DeF}"
                        action="-m limit --limit ${p1}  -j ACCEPT"
                    fi
                    
                # end LIMIT
                ## LOG
                elif [ "$action" == "log" -o "$action" == "LOG" ]; then
                    if [ -z "${p1}" ]; then
                        echo -e "${ReD}No log prefix specified with LayerRule's layer ${layer}.{Def}"
                        echo -e "${GrN}Using '${layer}' as log prefix!${DeF}"
                        prefix="${layer}"
                    fi
                    action="-j LOG"
                    LPsz=${#LogPrefix}
                    p1=${LayerRule[$((i+7))]:4:((32-LPsz))}
                    #action= "-j LOG --log-prefix \\\"${LogPrefix}${p1}\\\""
                                        
                # end LOG
                ## No ACTION
                elif [ "$action" == "" -o -z "$action" ]; then
                    action=""
                # end No Action
                ## error case
                else
                    echo -e "${ReD}Unknown action with LayerRule: '${action}'. Not Assigning an Action.${DeF}"
                    action=""
                fi  # end REJECT or LIMIT
            fi  # end  ACTION  area
        
            # slower-processing IF:  if [  ! -n "${LayerRule[$((i+2))]}" -a  -n "${LayerRule[$((i+4))]}"    -o    ! -n "${LayerRule[$((i+2))]}"  -a  -n "${LayerRule[$((i+6))]}"  ]; then
            if [ -z "${LayerRule[$((i+2))]}" ]  &&  [ -n "${LayerRule[$((i+4))]}" -o  -n "${LayerRule[$((i+6))]}" ]; then
                echo -e "${ReD}Error with LayerRule: "
                echo -n -e "  Layer:  "
                echo -n -e            "${LayerRule[$((i+0))]},  Proto: '${LayerRule[$((i+2))]}',  "
                echo -n -e            "src ip: '${LayerRule[$((i+3))]}',  src port: '${LayerRule[$((i+4))]}',  "
                echo    -e            "dest ip: '${LayerRule[$((i+5))]}',  dest port: '${LayerRule[$((i+6))]}',  action: '${LayerRule[$((i+7))]}'."
                echo -e "${GrN}Skipping rule.${DeF}"
                continue
            fi
            
# [ condition ] && (true || [ 1 == 1 ]) || false            

            if [ "$action" == "-j LOG" ]; then
                # BS section for if action is LOG (the --log-prefix  above fails!)
                case "$1" in   
                    1|2|3|4) # INPUT 1
                        $IPTABLES -t filter -I INPUT 1 ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} --log-prefix "${LogPrefix}${p1}" -m comment --comment "${desc}"
                        ;;
                    5|6|7|8|9|10|11|12|13|14|15|16|17|18) # INPUT append
                        $IPTABLES -t filter -A INPUT   ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} --log-prefix "${LogPrefix}${p1}" -m comment --comment "${desc}"
                        ;;
                    19) # FORWARD 1
                        $IPTABLES -t filter -I FORWARD 1 ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} --log-prefix "${LogPrefix}${p1}" -m comment --comment "${desc}"
                        ;;
                    20|21|22|23|24|25|26|27|28)  # FORWARD append
                        $IPTABLES -t filter -A FORWARD ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} --log-prefix "${LogPrefix}${p1}" -m comment --comment "${desc}"
                        ;;
                    29|30|31) # OUPUT 1
                        $IPTABLES -t filter -I OUTPUT 1 ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} --log-prefix "${LogPrefix}${p1}" -m comment --comment "${desc}"
                        ;;
                    32|33|34|35|36|37) # OUTPUT append
                        $IPTABLES -t filter -A OUTPUT  ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} --log-prefix "${LogPrefix}${p1}" -m comment --comment "${desc}"
                        ;;
                    *) # error case
                        echo -e "${ReD}LayerRule layer '${1}' is invalid.${DeF}"
                        ;;
                esac
                # end BS section for LOG action
            else
                case "$1" in
                    1|2|3|4) # INPUT 1
                        $IPTABLES -t filter -I INPUT 1 ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} -m comment --comment "${desc}"
                        ;;
                    5|6|7|8|9|10|11|12|13|14|15|16|17|18) # INPUT append
                        $IPTABLES -t filter -A INPUT   ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} -m comment --comment "${desc}"
                        ;;
                    19) # FORWARD 1
                        $IPTABLES -t filter -I FORWARD 1 ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} -m comment --comment "${desc}"
                        ;;
                    20|21|22|23|24|25|26|27|28)  # FORWARD append
                        $IPTABLES -t filter -A FORWARD ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} -m comment --comment "${desc}"
                        ;;
                    29|30|31) # OUPUT 1
                        $IPTABLES -t filter -I OUTPUT 1 ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} -m comment --comment "${desc}"
                        ;;
                    32|33|34|35|36|37) # OUTPUT append
                        $IPTABLES -t filter -A OUTPUT  ${Proto} ${srcIP} ${SrcP} ${DestIP} ${DestP} ${action} -m comment --comment "${desc}"
                        ;;
                    *) # error case
                        echo -e "${ReD}LayerRule layer '${1}' is invalid.${DeF}"
                        ;;
                esac
            fi
        fi
        fi
    done
} # end  InsertLayerRule (188 lines later...)




###
case "$1" in
  start)
    echo "Starting D.T Firewall $VER"

    # enable ip forwarding
    # echo 1 > /proc/sys/net/ipv4/ip_forward
    # mod probe ?

    # IPTables-Module
    $MODPROBE ip_tables
    $MODPROBE iptable_filter
    # Connection-Tracking-Module
    $MODPROBE ip_conntrack
    $MODPROBE ip_conntrack_irc
    $MODPROBE ip_conntrack_ftp
    if [ "${EnableLog}" == "true" -o "${EnableLog}" == "TRUE" ]; then
      $MODPROBE ipt_LOG

      # /etc/syslog.conf  :
      ### d.t firewall
      #kern.=debug    /var/log/firewall
      # /sbin/service syslog restart
      # /usr/sbin/service syslog restart  => unrecognized service

      #kern.warning   /bar/log/iptables.log
      # debian:
      #   /etc/init.d/sysklogd restart
      # redhat/centos:
      #   /etc/init.d/syslog restart
      #  --log-level 4: Level of logging. The level # 4 is for warning

      #disable console logging by commenting out this line in your syslog.conf
      #kern.* /dev/console
    fi


    # Table Flush
    $IPTABLES -F
    $IPTABLES -t nat -F
    $IPTABLES -t mangle -F
    $IPTABLES -t nat -X
    $IPTABLES -t mangle -X
    $IPTABLES -X

    
    # Default-Policies
    ## set at END of start script, in case an error occurs and blocks SSH!
    
    
    # brute force chain
    BRUTEF="BrutForce"  # brute force table name
    $IPTABLES -N $BRUTEF
    $IPTABLES -A $BRUTEF -j LOG --log-prefix "${LogPrefix}brute forcer"
    $IPTABLES -A $BRUTEF -j DROP





####  TODO: make this work -  bw rates 
    BW_Rates="off"

    #  BW_Rates section
    ## 
    # BW_REJECT-Chain
    REJECTER="BW_REJECT"
    if [ "$BW_Rates" != "off" -a "$BW_Rates" != "OFF" -a "$BW_Rates" != "disabled" -a "$BW_Rates" != "DISABLED" ]; then    
      $IPTABLES -N $REJECTER

     # BW_REJECT fill
### TODO: enable 'http/ftp redirect/vhost' for warning
      echo " Bandwith Rate of $BW_Rates enabled."
      $IPTABLES -A $REJECTER -p tcp -m limit --limit $BW_Rates -j LOG --log-prefix "${LogPrefix}REJECT TCP "
#      $IPTABLES -A $REJECTER -p tcp -j REJECT --reject-with tcp-reset
      $IPTABLES -A $REJECTER -p udp -m limit --limit $BW_Rates -j LOG --log-prefix "${LogPrefix}REJECT UDP "
#      $IPTABLES -A $REJECTER -p udp -j REJECT --reject-with icmp-port-unreachable
      $IPTABLES -A $REJECTER -p icmp -m limit --limit $BW_Rates -j LOG --log-prefix "${LogPrefix}DROP ICMP "
#      $IPTABLES -A $REJECTER -p icmp -j DROP
      $IPTABLES -A $REJECTER -m limit --limit $BW_Rates -j LOG --log-prefix "${LogPrefix}REJECT OTHER "
#      $IPTABLES -A $REJECTER -j REJECT --reject-with icmp-proto-unreachable

      $IPTABLES -A INPUT -j $REJECTER   -m comment --comment "for bandwidth overage"
      $IPTABLES -A OUTPUT -j $REJECTER

    fi
    ## 
    #  end BW_Rates  section
#### end TODO: make this work




    # DropTableName-Chain
    ## used for bad-packet dropping
    $IPTABLES -N ${DropTableName}
    if [ "$LOG_Droped" == "true" -o "$LOG_Droped" == "TRUE" -o "$LOG_Droped" == "yes" ]; then
      echo " Logging bad packets."
      $IPTABLES -A ${DropTableName} -j LOG --log-prefix "${LogPrefix}bad packet"   -m comment --comment "log bad data"
    fi
    $IPTABLES -A ${DropTableName} -j DROP   -m comment --comment "drop malformed data"



    InsertLayerRule "5"
# Block Spoofing - WAN ifaces ONLY!
    
#WAN#    $IPTABLES -I INPUT ! -i lo -s  10.0.0.0/8    -j DROP   -m comment --comment "block spoofing"
#   $IPTABLES -I INPUT ! -i lo -s 172.16.0.0/12  -j DROP   -m comment --comment "block spoofing"
#WAN#    $IPTABLES -I INPUT ! -i lo -s 192.168.0.0/16 -j DROP   -m comment --comment "block spoofing"
#   $IPTABLES -I INPUT ! -i lo -s 127.0.0.0/8    -j DROP   -m comment --comment "block spoofing"

# Reject packets from RFC1918 class networks (i.e., spoofed)
# iptables -A INPUT -s 10.0.0.0/8     -j DROP
# iptables -A INPUT -s 169.254.0.0/16 -j DROP
# iptables -A INPUT -s 172.16.0.0/12  -j DROP
# iptables -A INPUT -s 127.0.0.0/8    -j DROP
# 
# iptables -A INPUT -s 224.0.0.0/4      -j DROP
# iptables -A INPUT -d 224.0.0.0/4      -j DROP
# iptables -A INPUT -s 240.0.0.0/5      -j DROP
# iptables -A INPUT -d 240.0.0.0/5      -j DROP
# iptables -A INPUT -s 0.0.0.0/8        -j DROP
# iptables -A INPUT -d 0.0.0.0/8        -j DROP
# iptables -A INPUT -d 239.255.255.0/24 -j DROP
# iptables -A INPUT -d 255.255.255.255  -j DROP




    InsertLayerRule "6"
    # connection tracking
    # related, or established, ACCEPT!
    $IPTABLES -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT                   -m comment --comment "connection tracking INPUT"

    InsertLayerRule "7"
    echo ' Allowing Localhost'
    #Allow localhost.
    $IPTABLES -A INPUT -t filter -s 127.0.0.1 -j ACCEPT -m comment --comment "allow localhost"

    InsertLayerRule "8"
    # Loopback-Network-Communication allow
    $IPTABLES -A INPUT -i lo -j ACCEPT    -m comment --comment "loopback iface inbound"
   



    
    # a small section for OUTPUT chain in FILTER table
    ### 
    #InsertLayerRule "30"  TODO 
    ### loop for WHITELIST ( use WHITELIST file (end of file);  TODO: AND allow a second file AND script array )
    ## TODO
    #InsertLayerRule "31"  TODO 
    ### loop for Outbound BLACKLIST ( separate list as INPUT, AND array )
    
    InsertLayerRule "32"
    # giant if => used to check outbound packets for corruption
    OUT_BAD_PAC_DESC=()
    OUT_NEW_STATE=()
    OUT_NEW_DESC=()
    if [ "$Block_Corrupt_Outbound" == "false" -o "$Block_Corrupt_Outbound" == "0" -o "$Block_Corrupt_Outbound" == "no" ]; then
        # connection tracking
        $IPTABLES -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT   -m comment --comment "connection tracking OUTPUT"
        OUT_BAD_PAC_DESC="corrupt packets OUTPUT"
        OUT_NEW_STATE="NEW"
        OUT_NEW_DESC="new connections OUTPUT"
    else
        OUT_BAD_PAC_DESC="force check corrupt packets OUTPUT"
        OUT_NEW_STATE="NEW,ESTABLISHED,RELATED"
        OUT_NEW_DESC="new and connection tracking OUTPUT"
    fi # end  giant if, outbound packet corruption

    InsertLayerRule "33"
    # accept lo iface OUTPUT
    $IPTABLES -A OUTPUT -o lo -j ACCEPT   -m comment --comment "loopback iface outbound"

    InsertLayerRule "34"
    # Corrupt Packet drop
    $IPTABLES -A OUTPUT -m state --state INVALID -j DROP            -m comment --comment "${OUT_BAD_PAC_DESC}"

    InsertLayerRule "35" 
    # DROP/REJECT rules [TODO] - destination port blocking (source IP blocking) - iface? 
    ### loop for blocking outbound

    InsertLayerRule "36" # new+connection tracking - output
    # accept otherwise
    $IPTABLES -A OUTPUT -m state --state ${OUT_NEW_STATE} -j ACCEPT -m comment --comment "${OUT_NEW_DESC}"   
    InsertLayerRule "37" # log bogus outward connections (last rule)
    ###
    # end OUTPUT section




    # section for FORWARD chain in FILTER table
    ###
    InsertLayerRule "20"
    # connection tracking
    # related, or established, ACCEPT!
    $IPTABLES -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT                 -m comment --comment "connection tracking FORWARD"

    InsertLayerRule "21"
    # Force ACCEPT Rules [TODO]
    
    # unclean data (attacks, corrupt, ect) - FORWARD chain
    ### 
    InsertLayerRule "22"
    # Corrupt Packet drop 
    $IPTABLES -A FORWARD -m state --state INVALID -j DROP   -m comment --comment "corrupt packets FORWARD"
    InsertLayerRule "23"
    # Stealth Scans etc. DROPpen
    # Non Flags 
    $IPTABLES -A FORWARD -p tcp --tcp-flags ALL NONE -j $DropTableName   -m comment --comment "stealth scans"
    # SYN and FIN
    $IPTABLES -A FORWARD -p tcp --tcp-flags SYN,FIN SYN,FIN -j $DropTableName   -m comment --comment "SYN and FIN" 
    # SYN and RST set at same time
    $IPTABLES -A FORWARD -p tcp --tcp-flags SYN,RST SYN,RST -j $DropTableName   -m comment --comment "SYN and RST at same time"
    # FIN and RST set at same time
    $IPTABLES -A FORWARD -p tcp --tcp-flags FIN,RST FIN,RST -j $DropTableName   -m comment --comment "FIN and RST at same time"
    # FIN without ACK
    $IPTABLES -A FORWARD -p tcp --tcp-flags ACK,FIN FIN -j $DropTableName   -m comment --comment "FIN w-o ACK"
    # PSH without ACK
    $IPTABLES -A FORWARD -p tcp --tcp-flags ACK,PSH PSH -j $DropTableName   -m comment --comment "PSH w-o ACK"
    # URG without ACK
    $IPTABLES -A FORWARD -p tcp --tcp-flags ACK,URG URG -j $DropTableName   -m comment --comment "URG w-o ACK"
# added FORWARDs - copyied from INPUT
    # XMAS packets
    $IPTABLES -A FORWARD -p tcp --tcp-flags ALL ALL -j $DropTableName    -m comment --comment "XMAS packet drop"
    # Drop Null Packets
    $IPTABLES -A FORWARD -p tcp --tcp-flags ALL NONE -j $DropTableName   -m comment --comment "NULL packet drop"
    # more badflags  http://pikt.org/pikt/samples/iptables_tcp_flags_programs.cfg.html
    $IPTABLES -A FORWARD -p tcp --tcp-flags ALL FIN,PSH,URG -j $DropTableName          -m comment --comment "more badflags"
    $IPTABLES -A FORWARD -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j $DropTableName      -m comment --comment "more badflags"
    $IPTABLES -A FORWARD -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j $DropTableName  -m comment --comment "more badflags"
    # pettingers.org/code/firewall.html
    $IPTABLES -A FORWARD ! -i lo -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j $DropTableName -m comment --comment "from pettingers.org"
    # Force SYN packets check
    $IPTABLES -A FORWARD -p tcp ! --syn -m state --state NEW -j $DropTableName  -m comment --comment "force SYN packets check"
    InsertLayerRule "24"
    # Force Fragments packets check
    $IPTABLES -A FORWARD -f -j $DropTableName   -m comment --comment "force fragment packet check"
    ###
    # end unclean data - OUTPUT chain

    InsertLayerRule "25"
    ### Other flood protections - limit DoS
    # limits rate in FORWARD
    # http://netfilter.org/documentation/HOWTO/packet-filtering-HOWTO-7.html
    #    iptables -A FORWARD -p tcp --syn -m limit --limit 1/s -j ACCEPT
    #    iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s -j ACCEPT
    #    iptables -A FORWARD -p icmp --icmp-type echo-request -m limit --limit 1/s -j ACCEPT
    # TODO: research wtf those 3 lines mean
    for (( i=0; i< ${#OTHER_FLOODS[@]}; i++ ))
    do
      if (( $i % 2 == 0 )); then
        OFP=( )
        if [ "${OTHER_FLOODS[$i]}"   == "syn flood" ]; then
          OFP="-p tcp --syn -m limit"
        elif [ "${OTHER_FLOODS[$i]}" == "furtive port scanner" ]; then
          OFP="-p tcp --tcp-flags SYN,ACK,FIN,RST RST"
        elif [ "${OTHER_FLOODS[$i]}" == "ping of death" ]; then
          OFP="-p icmp --icmp-type echo-request"
        else
          echo -e "${ReD}there is no rule type for OTHER_FLOODS=(\"${OTHER_FLOODS[$i]}\" \"${OTHER_FLOODS[$((i+1))]}\"), skipping it.${DeF}"
        fi
          
        if [ "${OFP}" != "" ]; then
          $IPTABLES -A FORWARD ${OFP} -m limit --limit ${OTHER_FLOODS[$((i+1))]} -j ACCEPT   -m comment --comment "limit DoS ${OTHER_FLOODS[$i]}"
        fi
      fi
    done

    InsertLayerRule "26"
    ## TODO: good-packet accept rules (PD, PSD, PISD, PID)
    ## TODO!

    InsertLayerRule "27"
    # allow FORWARD after all them bad packet checks
    $IPTABLES -A FORWARD ! -i ppp0 -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT   -m comment --comment "connection tracking FORWARD"

    InsertLayerRule "28" # log bogus forward connections (last rule)
    ###
    # end FORWARD chain in FILTER table
    
    

    #
    ## FILTER INPUT chain
    # unclean data (attacks, corrupt, ect) - INPUT chain
    ### 
    InsertLayerRule "9"
    # Corrupt Packet drop 
    $IPTABLES -A INPUT -m state --state INVALID -j DROP     -m comment --comment "corrupt packets INPUT"
    InsertLayerRule "10"
    # Stealth Scans etc. DROPpen
    # Non Flags 
    $IPTABLES -A INPUT -p tcp --tcp-flags ALL NONE -j $DropTableName     -m comment --comment "stealth scans"
    # SYN and FIN
    $IPTABLES -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j $DropTableName     -m comment --comment "SYN and FIN" 
    # SYN and RST set at same time
    $IPTABLES -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j $DropTableName     -m comment --comment "SYN and RST at same time"
    # FIN and RST set at same time
    $IPTABLES -A INPUT -p tcp --tcp-flags FIN,RST FIN,RST -j $DropTableName     -m comment --comment "FIN and RST at same time"
    # FIN without ACK
    $IPTABLES -A INPUT -p tcp --tcp-flags ACK,FIN FIN -j $DropTableName     -m comment --comment "FIN w-o ACK"
    # PSH without ACK
    $IPTABLES -A INPUT -p tcp --tcp-flags ACK,PSH PSH -j $DropTableName     -m comment --comment "PSH w-o ACK"
    # URG without ACK
    $IPTABLES -A INPUT -p tcp --tcp-flags ACK,URG URG -j $DropTableName     -m comment --comment "URG w-o ACK"
    # XMAS packets
    $IPTABLES -A INPUT -p tcp --tcp-flags ALL ALL -j $DropTableName    -m comment --comment "XMAS packet drop"
    # Drop Null Packets
    $IPTABLES -A INPUT -p tcp --tcp-flags ALL NONE -j $DropTableName   -m comment --comment "NULL packet drop"
    # more badflags  http://pikt.org/pikt/samples/iptables_tcp_flags_programs.cfg.html
    $IPTABLES -A INPUT -p tcp --tcp-flags ALL FIN,PSH,URG -j $DropTableName          -m comment --comment "more badflags"
    $IPTABLES -A INPUT -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j $DropTableName      -m comment --comment "more badflags"
    $IPTABLES -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j $DropTableName  -m comment --comment "more badflags"
    # pettingers.org/code/firewall.html
    $IPTABLES -A INPUT ! -i lo -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j $DropTableName -m comment --comment "from pettingers.org"
    # Force SYN packets check
    $IPTABLES -A INPUT -p tcp ! --syn -m state --state NEW -j $DropTableName   -m comment --comment "force SYN packets check"
    InsertLayerRule "11"
    # Force Fragments packets check
    $IPTABLES -A INPUT -f -j $DropTableName   -m comment --comment "force fragment packet check"
    ###
    # end unclean data - INPUT chain




    InsertLayerRule "12"
    # Drop all packets to port 111 except those from localhost
    $IPTABLES -A INPUT ! -s 127.0.0.0/8 -p tcp --dport 111 -j DROP   -m comment --comment "RPC related, allow only localhost"

    # kill off identd quick
    $IPTABLES -A INPUT -p tcp ! -i lo   --dport 113 -j REJECT --reject-with tcp-reset   -m comment --comment "kill off identd quick"

    # Don't log route packets coming from routers - too much logging
    $IPTABLES -A INPUT -p udp ! -i lo   --dport 520 -j REJECT   -m comment --comment "do not log route packets from routers"

    
      
    InsertLayerRule "13"
    
    # Block Ping
    if [ $"${Block_Ping[0]}" == "false" -o "${Block_Ping[0]}" == "FALSE" -o "${Block_Ping[0]}" == "no" ]; then
      $IPTABLES  -A INPUT -p icmp --icmp-type echo-request -j ACCEPT   -m comment --comment "allow ping"
      echo " Ping: allowed."
    elif [ "${Block_Ping[0]}" == "drop" -o "${Block_Ping[0]}" == "DROP" ]; then 
      $IPTABLES  -A INPUT -p icmp --icmp-type echo-request -j DROP     -m comment --comment "drop ping"
    elif [ "${Block_Ping[0]}" == "reject" -o "${Block_Ping[0]}" == "REJECT" ]; then 
      sendBack=( )
      case "${Block_Ping[1]}" in
          1|icmp-port-unreachable)
              sendBack="icmp-port-unreachable"  ;;
          2|icmp-net-unreachable)
              sendBack="icmp-net-unreachable"   ;;
          3|icmp-host-unreachable)
              sendBack="icmp-host-unreachable"  ;;
          4|icmp-proto-unreachable)
              sendBack="icmp-proto-unreachable" ;;
          5|icmp-net-prohibited)
              sendBack="icmp-net-prohibited"    ;;
          6|icmp-host-prohibited)
              sendBack="icmp-host-prohibited"   ;;
          *)
              echo -e "${ReD}Block Ping Reject bounce-back-error typo: \"${Block_Ping[1]}\", using \"icmp-port-unreachable\".${DeF}"
              sendBack="icmp-port-unreachable"  ;;
      esac
      $IPTABLES -A INPUT -p icmp --icmp-type echo-request -j REJECT --reject-with ${sendBack} -m comment --comment "reject ping" 
      echo " Ping: Reject with ${sendBack}."
    ### ICMP Rate limits (elimiates some SMURF packets)      
    elif [ "${Block_Ping[0]}" == "limit" -o "${Block_Ping[0]}" == "LIMIT" ]; then
        # dont know what the first two lines do - TODO: research wtf those 2 lines mean
        $IPTABLES -A INPUT -p icmp -m icmp --icmp-type address-mask-request -j DROP
        $IPTABLES -A INPUT -p icmp -m icmp --icmp-type timestamp-request -j DROP
        $IPTABLES -A INPUT -p icmp -m icmp -m limit --limit ${Block_Ping[1]} --limit-burst ${Block_Ping[2]} -j ACCEPT
        echo " Ping: Limited at ${Block_Ping[1]} with burst of ${Block_Ping[2]}."
    fi



       



    

# HTTP flood check
# http://lists.netfilter.org/pipermail/netfilter/2003-June/044762.html
#    $IPTABLES -N flood-chk
#    $IPTABLES -A INPUT -p tcp --dport 8080 --syn -j flood-chk -m comment --comment "HEEEEERRRRRRRRRR"
#    $IPTABLES -A flood-chk -m limit --limit 1/sec --limit-burst 2 -j RETURN
#    $IPTABLES -A flood-chk -j LOG --log-prefix "${LogPrefix}flood packet"
#    $IPTABLES -A flood-chk -j DROP | REJECT
    
    InsertLayerRule "14"  # INPUT flood protections - TODO
    ### Other flood protections - limit DoS [ Implemented in FORWARD section ]
    # limits rate in FORWARD - fuction here for future FLOOD additions (for INPUT table)
#    for (( i=0; i< ${#OTHER_FLOODS[@]}; i++ ))
#    do
#      if (( $i % 2 == 0 )); then
#        OFP=( )
#        if [ "${OTHER_FLOODS[$i]}"   == "syn flood" ]; then
#          OFP="-p tcp --syn -m limit"
#        elif [ "${OTHER_FLOODS[$i]}" == "furtive port scanner" ]; then
#          OFP="-p tcp --tcp-flags SYN,ACK,FIN,RST RST"
#        elif [ "${OTHER_FLOODS[$i]}" == "ping of death" ]; then
#          OFP="-p icmp --icmp-type echo-request"
#        else
#          echo -e "${ReD}there is no rule type for OTHER_FLOODS=(\"${OTHER_FLOODS[$i]}\" \"${OTHER_FLOODS[$((i+1))]}\"), skipping it.${DeF}"
#        fi
#
#        if [ "${OFP}" != "" ]; then
#          $IPTABLES -A FORWARD ${OFP} -m limit --limit ${OTHER_FLOODS[$((i+1))]} -j ACCEPT   -m comment --comment "limit DoS ${OTHER_FLOODS[$i]}"
#        fi
#      fi
#    done


   
    InsertLayerRule "15"
    # Block Brute Force 
    for (( i=0; i< ${#BruteForce[@]}; i++ ))
    do
      if (( $i % 2 == 0 )); then
        $IPTABLES -A INPUT -p tcp --dport ${BruteForce[$i]} \
          -m state --state NEW -m recent --set --name "BF_${BruteForce[$((i+1))]}"  \
          -m comment --comment "${BruteForce[$((i+1))]}"
        $IPTABLES -A INPUT -p tcp --dport ${BruteForce[$i]} \
          -m state --state NEW -m recent --update --seconds 60 --hitcount 8 --rttl --name "BF_${BruteForce[$((i+1))]}" -j ${BRUTEF} \
          -m comment --comment "${BruteForce[$((i+1))]}"
      fi
    done
   

    
    InsertLayerRule "16"
### general services (allow all sources ips):port:desc
### specific:  Proto,  Dest port
#   PD_SRV+=( "<DESC>" "<tcp|udp|both>" "<PORT>" )
    for (( i=0; i< ${#PD_SRV[@]}; i++ ))
    do
      if (( $i % 3 == 0 )); then
        proto=( )
        if [ "${PD_SRV[$((i+1))]}" == "tcp" -o "${PD_SRV[$((i+1))]}" == "TCP" ]; then
          proto="tcp"
        elif [ "${PD_SRV[$((i+1))]}" == "udp" -o "${PD_SRV[$((i+1))]}" == "UDP" ]; then
          proto="udp"
        elif [ "${PD_SRV[$((i+1))]}" == "both" -o "${PD_SRV[$((i+1))]}" == "BOTH" ]; then
          $IPTABLES -t filter -A INPUT -m state --state NEW -p tcp      --dport ${PD_SRV[$((i+2))]} -j ACCEPT -m comment --comment "${PD_SRV[$i]} tcp"
          proto="udp"
        fi
        
        $IPTABLES   -t filter -A INPUT -m state --state NEW -p ${proto} --dport ${PD_SRV[$((i+2))]} -j ACCEPT -m comment --comment "${PD_SRV[$i]} ${proto}"
      fi
    done


### specific:  Proto,  src IP,  Dest port
#   PID_SRV+=( "<DESC>" "<tcp|udp|both>" "<src ip>" "<dst port | all>"
    for (( i=0; i< ${#PID_SRV[@]}; i++ ))
    do
      if (( $i % 4 == 0 )); then
        proto=( )
        port=( )
        if [ ${PID_SRV[$((i+3))]} == "all" -o ${PID_SRV[$((i+3))]} == "ALL" ]; then
            dport=""
        else
            dport="--dport ${PID_SRV[$((i+3))]}"
        fi
        
        if [ "${PID_SRV[$((i+1))]}" == "tcp" -o "${PID_SRV[$((i+1))]}" == "TCP" ]; then
          proto="tcp"
        elif [ "${PID_SRV[$((i+1))]}" == "udp" -o "${PID_SRV[$((i+1))]}" == "UDP" ]; then
          proto="udp"
        elif [ "${PID_SRV[$((i+1))]}" == "both" -o "${PID_SRV[$((i+1))]}" == "BOTH" ]; then
          $IPTABLES -t filter -A INPUT -m state --state NEW -s ${PID_SRV[$((i+2))]} -p tcp \
            ${dport} -j ACCEPT -m comment --comment "${PID_SRV[$i]} tcp"
          proto="udp"
        fi

        $IPTABLES   -t filter -A INPUT -m state --state NEW -s ${PID_SRV[$((i+2))]} -p ${proto} \
            ${dport} -j ACCEPT -m comment --comment "${PID_SRV[$i]} ${proto}"
      fi
    done


### specific:  Proto,  Src port,  Dest port
#   PSD_SRV+=( "<DESC>" "<tcp|udp|both>" "<Source PORT>" "<Destination PORT>")
    for (( i=0; i< ${#PSD_SRV[@]}; i++ ))
    do
      if (( $i % 4 == 0 )); then
        proto=( )
        if [ "${PSD_SRV[$((i+1))]}" == "tcp" -o "${PSD_SRV[$((i+1))]}" == "TCP" ]; then
          proto="tcp"
        elif [ "${PSD_SRV[$((i+1))]}" == "udp" -o "${PSD_SRV[$((i+1))]}" == "UDP" ]; then
          proto="udp"
        elif [ "${PSD_SRV[$((i+1))]}" == "both" -o "${PSD_SRV[$((i+1))]}" == "BOTH" ]; then
          $IPTABLES -t filter -A INPUT -m state --state NEW -p tcp      --sport ${PSD_SRV[$((i+2))]} --dport ${PSD_SRV[$((i+3))]} -j ACCEPT -m comment --comment "${PSD_SRV[$i]} tcp"
          proto="udp"
        fi

        $IPTABLES   -t filter -A INPUT -m state --state NEW -p ${proto} --sport ${PSD_SRV[$((i+2))]} --dport ${PSD_SRV[$((i+3))]} -j ACCEPT -m comment --comment "${PSD_SRV[$i]} ${proto}"
      fi
    done


### specific:  Proto,  src IP,  Src port,  Dest port
#   PISD_SRV+=( "<DESC>" "<tcp|udp|both>" "<src ip>" "<src port>" "<dest port>"
    for (( i=0; i< ${#PISD_SRV[@]}; i++ ))
    do
      if (( $i % 5 == 0 )); then
        proto=( )
        if [ "${PISD_SRV[$((i+1))]}" == "tcp" -o "${PISD_SRV[$((i+1))]}" == "TCP" ]; then
          proto="tcp"
        elif [ "${PISD_SRV[$((i+1))]}" == "udp" -o "${PISD_SRV[$((i+1))]}" == "UDP" ]; then
          proto="udp"
        elif [ "${PISD_SRV[$((i+1))]}" == "both" -o "${PISD_SRV[$((i+1))]}" == "BOTH" ]; then
          $IPTABLES -t filter -A INPUT -m state --state NEW -s ${PISD_SRV[$((i+2))]} -p tcp \
             --sport ${PISD_SRV[$((i+3))]} --dport ${PISD_SRV[$((i+4))]} -j ACCEPT \
             -m comment --comment "${PISD_SRV[$i]} tcp"
          proto="udp"
        fi
        
        $IPTABLES   -t filter -A INPUT -m state --state NEW -s ${PISD_SRV[$((i+2))]} -p ${proto} \
             --sport ${PISD_SRV[$((i+3))]} --dport ${PISD_SRV[$((i+4))]} -j ACCEPT \
             -m comment --comment "${PISD_SRV[$i]} ${proto}"
      fi
    done



    


    
    InsertLayerRule "17"
    # Samba | HTPC
    for (( i=0; i< ${#SAMBA[@]}; i++ ))
    do
      $IPTABLES -A INPUT -p udp -m udp -s ${SAMBA[$i]} --dport 137 -j ACCEPT   -m comment --comment "SAMBA $i"
      $IPTABLES -A INPUT -p udp -m udp -s ${SAMBA[$i]} --dport 138 -j ACCEPT   -m comment --comment "SAMBA $i"
      $IPTABLES -A INPUT -m state --state NEW -m tcp -p tcp -s ${SAMBA[$i]} --dport 139 -j ACCEPT   -m comment --comment "SAMBA $i"
      $IPTABLES -A INPUT -m state --state NEW -m tcp -p tcp -s ${SAMBA[$i]} --dport 445 -j ACCEPT   -m comment --comment "SAMBA $i"
    done
        # All IPs
    #     $IPTABLES -A INPUT -p udp -m udp --dport 137 -j ACCEPT
    #     $IPTABLES -A INPUT -p udp -m udp --dport 138 -j ACCEPT
    #     $IPTABLES -A INPUT -m state --state NEW -m tcp -p tcp --dport 139 -j ACCEPT
    #     $IPTABLES -A INPUT -m state --state NEW -m tcp -p tcp --dport 445 -j ACCEPT







    

    # Max. 500/Seconds (5/Sec) send
#    echo 5 > /proc/sys/net/ipv4/icmp_ratelimit

    # Memory Allocation and -Timing for IP-De/-Fragmenting
#    echo 262144 > /proc/sys/net/ipv4/ipfrag_high_thresh
#    echo 196608 > /proc/sys/net/ipv4/ipfrag_low_thresh
#    echo 30 > /proc/sys/net/ipv4/ipfrag_time

    # TCP-FIN-Timeout to Protection for DoS-Attack
#    echo 30 > /proc/sys/net/ipv4/tcp_fin_timeout

   # Maximal 3 Answers on TCP-SYN
#    echo 3 > /proc/sys/net/ipv4/tcp_retries1

    # TCP-Packet maximally 15x repeat
#    echo 15 > /proc/sys/net/ipv4/tcp_retries2






    
   ### Blacklist
   #
   if [ ! -r "$BLACKLIST" ]; then
     echo -e "${ReD}cannot read Blacklist at \"${BLACKLIST}\"!${DeF}"
   else
     bl=1
     for x in `grep -v ^# $BLACKLIST | awk '{print $1}'`; do
       if [ "$bl" == "1" ]; then  echo " Denying Blacklisted IPs:"; fi
       echo "    $bl: $x"
       $IPTABLES -I INPUT ${bl} -t filter -s $x -j DROP   -m comment --comment "blacklist ${bl}"
       bl=$((bl+1));
     done
   fi
   InsertLayerRule "4"   # input  blacklist
   InsertLayerRule "31"  # output blacklist
   


   ###  SSH Guard
   #
   if [ "${UseSSHGuard}" == "true" -o "${UseSSHGuard}" == "TRUE" ]; then
     $IPTABLES -N ${SSHG_TableName}
     $IPTABLES -I INPUT 1 ${sshguard_params} ${sshguard_moreps} -j ${SSHG_TableName}   -m comment --comment "sshguard"
     echo " SSHGuard initiated:"
     echo "   iptables -I INPUT 1 ${sshguard_params} ${sshguard_moreps} -j ${SSHG_TableName} -m comment --comment \"sshguard\""
   fi
   InsertLayerRule "3"  # sshguard (input)
    


   ### Whitelist
   #
### find . -type f | grep -s ".*\.sh$" | while read a; do chmod +x "$a"; done
   if [ ! -r "$WHITELIST" ]; then
     echo -e "${ReD}cannot read Whitelist at \"${WHITELIST}\", allowing ALL traffic!${DeF}"
     $IPTABLES -I INPUT 1 -j ACCEPT     -m comment --comment "whitelist error, allowing all"
     $IPTABLES -I FORWARD 1 -j ACCEPT   -m comment --comment "whitelist error, allowing all"
     $IPTABLES -I OUTPUT 1 -j ACCEPT    -m comment --comment "whitelist error, allowing all"
   else
     wl=1;
     for x in `grep -v ^# $WHITELIST | awk '{print $1}'`; do
       if [ "$wl" == "1" ]; then  echo " Permitting Whitelisted IPs:"; fi
       echo "    $wl: $x"
       $IPTABLES -I INPUT ${wl} -t filter -s $x -j ACCEPT   -m comment --comment "whitelist ${wl}"
# IF          $IPTABLES -I OUTPUT ${wl} -t filter -s $x -j ACCEPT   -m comment --comment "whitelist ${wl}"
       wl=$((wl+1));
     done
   fi
   InsertLayerRule "2"  # input  whitelist
   InsertLayerRule "30" # output whitelist
   



   # Log All Packets (inserted as first rule)
   if [ "$LOG_ALL_PACKETS" == "true" -o "$LOG_ALL_PACKETS" == "1" -o "$LOG_ALL_PACKETS" == "yes" ]; then
       echo -e " Logging All Packets."
       $IPTABLES -I INPUT 1 -j LOG --log-prefix "${LogPrefix}Log All INPUT"     -m comment --comment "Log All INPUT"
       $IPTABLES -I OUTPUT 1 -j LOG --log-prefix "${LogPrefix}Log All OUTPUT"   -m comment --comment "Log All OUTPUT"
       $IPTABLES -I FORWARD 1 -j LOG --log-prefix "${LogPrefix}Log All FORWARD" -m comment --comment "Log All FORWARD"
   fi

   InsertLayerRule "1"  # input   - LogAllPackets
   InsertLayerRule "18" # log bogus inbound connections (last rule)
   InsertLayerRule "19" # forward - LogAllPackets
   InsertLayerRule "29" # output  - LogAllPackets

    
   
    # Log Bogus and Last Line segment  
    ### 
    ## INPUT_LOG_BOGUS
    if [ "$INPUT_LOG_BOGUS" == "true" -o "$INPUT_LOG_BOGUS" == "TRUE" ]; then
      echo " Logging bogus/leftover inbound traffic."
      $IPTABLES -A INPUT -j LOG --log-prefix "${LogPrefix}log bogus inbound"   -m comment --comment "log bogus inbound connections"
    fi
    ## INPUT_LAST_LINE
    if [ "$INPUT_LAST_LINE" == "REJECT" -o "$INPUT_LAST_LINE" == "reject" ]; then
      $IPTABLES -A INPUT -p tcp -j REJECT --reject-with tcp-reset               -m comment --comment "send tcp reset"
      #$IPTABLES -A INPUT -p udp -j DROP                             -m comment --comment "drop udp"
      $IPTABLES -A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable   -m comment --comment "send port unreachable udp"
    fi

    ## FORWARD_LOG_BOGUS
    if [ "$FORWARD_LOG_BOGUS" == "true" -o "$FORWARD_LOG_BOGUS" == "TRUE" ]; then
      echo " Logging bogus/leftover forward traffic."
      $IPTABLES -A FORWARD -j LOG --log-prefix "${LogPrefix}log bogus forward"   -m comment --comment "log bogus forward connections"
    fi
    ## FORWARD_LAST_LINE
    if [ "$FORWARD_LAST_LINE" == "REJECT" -o "$FORWARD_LAST_LINE" == "reject" ]; then
      $IPTABLES -A FORWARD -p tcp -j REJECT --reject-with tcp-reset               -m comment --comment "send tcp reset"
      #$IPTABLES -A FORWARD -p udp -j DROP                             -m comment --comment "drop udp"
      $IPTABLES -A FORWARD -p udp -j REJECT --reject-with icmp-port-unreachable   -m comment --comment "send port unreachable udp"
    fi

    ## OUTPUT_LOG_BOGUS
    if [ "$OUTPUT_LOG_BOGUS" == "true" -o "$OUTPUT_LOG_BOGUS" == "TRUE" ]; then
      echo " Logging bogus/leftover outbound traffic."
      $IPTABLES -A OUTPUT -j LOG --log-prefix "${LogPrefix}log bogus outbound"   -m comment --comment "log bogus outbound connections"
    fi
    ## OUTPUT_LAST_LINE
    if [ "$OUTPUT_LAST_LINE" == "REJECT" -o "$OUTPUT_LAST_LINE" == "reject" ]; then
      $IPTABLES -A OUTPUT -p tcp -j REJECT --reject-with tcp-reset               -m comment --comment "send tcp reset"
      #$IPTABLES -A OUTPUT -p udp -j DROP                             -m comment --comment "drop udp"
      $IPTABLES -A OUTPUT -p udp -j REJECT --reject-with icmp-port-unreachable   -m comment --comment "send port unreachable udp"
    fi
    ### 
    # end Log Bogus and Last Line segment 
   


   # Default-Policies   
   $IPTABLES -P INPUT DROP
   $IPTABLES -P OUTPUT DROP
   $IPTABLES -P FORWARD DROP
   
   
   
   
   echo "Firewall Started"
    ;;

  stop)
    echo "FW Script Stopped"
    # Table Flush
    $IPTABLES -F
    $IPTABLES -t nat -F
    $IPTABLES -t mangle -F
    $IPTABLES -X
    $IPTABLES -t nat -X
    $IPTABLES -t mangle -X
    # Default-Policies set
    $IPTABLES -P INPUT ACCEPT
    $IPTABLES -P OUTPUT ACCEPT
    $IPTABLES -P FORWARD ACCEPT
    ;;
  
  restart)
      echo -e "D.T Firewall $VER"
      echo "Restarting Firewall"
      sleep 2
      echo "Flushing Firewall..."
      sleep 1
     echo "Starting Firewall..."
     $SCRIPT start
     sleep 1
     echo "Saving New Settings..."
     echo "Firewall On..."
     echo " "
      ;; 

  save)
    echo -e "D.T Firewall $VER"
    echo "Saving Tables"
    $IPTABLESSAVE > $FWSAVE
    echo "IPTable Rules Saved"
    ;;
    
  restore)
    echo -e "D.T Firewall $VER"
    echo "Restoring IPTables Rules"
    $IPTABLESRESTORE < $FWSAVE
    echo "IPTable Rules Restored"
    ;;    

  status)
    echo -e "D.T Firewall $VER"
    echo "Table Filter"
    $IPTABLES -L -vn
    echo "Table Nat"
    $IPTABLES -t nat -L -vn
    echo "Table Mangle"
    $IPTABLES -t mangle -L -vn
    ;;

  *)
    echo -e "D.T Firewall $VER"
    echo -e "${ReD}Incorrect Call${DeF}"
    echo "Syntax: $0 {start|stop|restart|save|restore|status}"
    exit 1
    ;;

esac

